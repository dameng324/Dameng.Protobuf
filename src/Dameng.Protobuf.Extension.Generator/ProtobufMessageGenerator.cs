using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Dameng.Protobuf.Extension.Generator;

[Generator]
public class ProtobufMessageGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context) { }

    public void Execute(GeneratorExecutionContext context)
    {
        foreach (var syntaxTree in context.Compilation.SyntaxTrees)
        {
            var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
            foreach (var typeDeclaration in syntaxTree.GetRoot().DescendantNodesAndSelf())
            {
                if (typeDeclaration is not ClassDeclarationSyntax classDeclaration)
                    continue;

                var targetType = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

                if (targetType is null)
                    continue;

                var attributes = targetType.GetAttributes();

                // Look for ProtoContract attribute
                var protoContractAttribute = attributes.FirstOrDefault(attribute =>
                    attribute.AttributeClass!.ToDisplayString().Equals("Dameng.Protobuf.Extension.ProtoContractAttribute")
                );

                if (protoContractAttribute is null)
                    continue;

                // Generate the protobuf message implementation
                var sourceCode = GenerateProtobufMessage(targetType, context);
                
                var fileName = $"{targetType.Name}.Protobuf.g.cs";
                context.AddSource(fileName, SourceText.From(sourceCode, Encoding.UTF8));
            }
        }
    }

    private string GenerateProtobufMessage(INamedTypeSymbol targetType, GeneratorExecutionContext context)
    {
        var namespaceName = targetType.ContainingNamespace.ToDisplayString();
        var className = targetType.Name;
        
        var sourceBuilder = new StringBuilder();
        
        sourceBuilder.AppendLine("// <auto-generated>");
        sourceBuilder.AppendLine("// Generated by Dameng.Protobuf.Extension");
        sourceBuilder.AppendLine("// </auto-generated>");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("using System;");
        sourceBuilder.AppendLine("using System.Collections.Generic;");
        sourceBuilder.AppendLine("using System.Collections.Concurrent;");
        sourceBuilder.AppendLine("using Google.Protobuf;");
        sourceBuilder.AppendLine("using Google.Protobuf.Collections;");
        sourceBuilder.AppendLine("using Google.Protobuf.Reflection;");
        sourceBuilder.AppendLine("using Google.Protobuf.WellKnownTypes;");
        sourceBuilder.AppendLine("using Dameng.Protobuf.Extension;");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine($"namespace {namespaceName}");
        sourceBuilder.AppendLine("{");
        
        // Generate the partial class implementation
        sourceBuilder.AppendLine($"    partial class {className} : IMessage<{className}>, IPbMessageParser<{className}>");
        sourceBuilder.AppendLine("    {");
        
        // Generate static parser
        sourceBuilder.AppendLine($"        private static readonly MessageParser<{className}> _parser = new MessageParser<{className}>(() => new {className}());");
        sourceBuilder.AppendLine($"        public static MessageParser<{className}> Parser {{ get {{ return _parser; }} }}");
        sourceBuilder.AppendLine();
        
        // Generate MessageDescriptor (placeholder for now)
        sourceBuilder.AppendLine("        public static MessageDescriptor Descriptor => throw new System.NotImplementedException(\"Descriptor not implemented yet\");");
        sourceBuilder.AppendLine("        MessageDescriptor IMessage.Descriptor => Descriptor;");
        sourceBuilder.AppendLine();
        
        // Generate unknown fields
        sourceBuilder.AppendLine("        private UnknownFieldSet _unknownFields;");
        sourceBuilder.AppendLine();
        
        // Generate field backing stores and properties with protobuf semantics
        var protoMembers = GetProtoMembers(targetType);
        GenerateFieldsAndProperties(sourceBuilder, protoMembers, className);
        
        // Generate Clone method
        sourceBuilder.AppendLine($"        public {className} Clone()");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine($"            return new {className}(this);");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        // Generate copy constructor
        GenerateCopyConstructor(sourceBuilder, protoMembers, className);
        
        // Generate Equals methods
        GenerateEqualsMethods(sourceBuilder, protoMembers, className);
        
        // Generate GetHashCode
        GenerateGetHashCode(sourceBuilder, protoMembers);
        
        // Generate ToString
        GenerateToString(sourceBuilder, className);
        
        // Generate protobuf serialization methods
        GenerateSerializationMethods(sourceBuilder, protoMembers, className);
        
        sourceBuilder.AppendLine("    }");
        sourceBuilder.AppendLine("}");
        
        return sourceBuilder.ToString();
    }

    private List<ProtoMember> GetProtoMembers(INamedTypeSymbol targetType)
    {
        var members = new List<ProtoMember>();
        
        foreach (var member in targetType.GetMembers())
        {
            if (member is not IPropertySymbol property || property.IsStatic)
                continue;
                
            var protoMemberAttr = property.GetAttributes().FirstOrDefault(attr =>
                attr.AttributeClass?.ToDisplayString().Equals("Dameng.Protobuf.Extension.ProtoMemberAttribute") == true);
                
            if (protoMemberAttr == null)
                continue;
                
            var tag = (int)protoMemberAttr.ConstructorArguments[0].Value!;
            members.Add(new ProtoMember
            {
                Name = property.Name,
                Type = property.Type,
                Tag = tag,
                Property = property
            });
        }
        
        return members.OrderBy(m => m.Tag).ToList();
    }

    private void GenerateFieldsAndProperties(StringBuilder sourceBuilder, List<ProtoMember> members, string className)
    {
        foreach (var member in members)
        {
            var fieldName = ToCamelCase(member.Name) + "_";
            var typeName = GetProtobufTypeName(member.Type);
            var defaultValue = GetDefaultValue(member.Type);
            
            // Generate field number constant
            sourceBuilder.AppendLine($"        public const int {member.Name}FieldNumber = {member.Tag};");
            
            // Generate backing field
            sourceBuilder.AppendLine($"        private {typeName} {fieldName}{defaultValue};");
            
            // Generate property
            sourceBuilder.AppendLine($"        public {GetPublicTypeName(member.Type)} {member.Name}");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine($"            get {{ return {GetFieldAccessor(member.Type, fieldName)}; }}");
            sourceBuilder.AppendLine($"            set {{ {GetFieldSetter(member.Type, fieldName, "value")} }}");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();
        }
    }

    private void GenerateCopyConstructor(StringBuilder sourceBuilder, List<ProtoMember> members, string className)
    {
        sourceBuilder.AppendLine($"        public {className}({className} other) : this()");
        sourceBuilder.AppendLine("        {");
        foreach (var member in members)
        {
            var fieldName = ToCamelCase(member.Name) + "_";
            if (IsCollectionType(member.Type))
            {
                sourceBuilder.AppendLine($"            {fieldName} = other.{fieldName}.Clone();");
            }
            else if (IsMessageType(member.Type))
            {
                sourceBuilder.AppendLine($"            {fieldName} = other.{fieldName} != null ? other.{fieldName}.Clone() : null;");
            }
            else
            {
                sourceBuilder.AppendLine($"            {fieldName} = other.{fieldName};");
            }
        }
        sourceBuilder.AppendLine("            _unknownFields = UnknownFieldSet.Clone(other._unknownFields);");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
    }

    private void GenerateEqualsMethods(StringBuilder sourceBuilder, List<ProtoMember> members, string className)
    {
        sourceBuilder.AppendLine("        public override bool Equals(object other)");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine($"            return Equals(other as {className});");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        sourceBuilder.AppendLine($"        public bool Equals({className} other)");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            if (ReferenceEquals(other, null)) return false;");
        sourceBuilder.AppendLine("            if (ReferenceEquals(other, this)) return true;");
        
        foreach (var member in members)
        {
            var fieldName = ToCamelCase(member.Name) + "_";
            if (IsCollectionType(member.Type))
            {
                sourceBuilder.AppendLine($"            if (!{fieldName}.Equals(other.{fieldName})) return false;");
            }
            else
            {
                sourceBuilder.AppendLine($"            if ({member.Name} != other.{member.Name}) return false;");
            }
        }
        
        sourceBuilder.AppendLine("            return Equals(_unknownFields, other._unknownFields);");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
    }

    private void GenerateGetHashCode(StringBuilder sourceBuilder, List<ProtoMember> members)
    {
        sourceBuilder.AppendLine("        public override int GetHashCode()");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            int hash = 1;");
        
        foreach (var member in members)
        {
            sourceBuilder.AppendLine($"            if ({member.Name} != null) hash ^= {member.Name}.GetHashCode();");
        }
        
        sourceBuilder.AppendLine("            if (_unknownFields != null) hash ^= _unknownFields.GetHashCode();");
        sourceBuilder.AppendLine("            return hash;");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
    }

    private void GenerateToString(StringBuilder sourceBuilder, string className)
    {
        sourceBuilder.AppendLine("        public override string ToString()");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            return JsonFormatter.ToDiagnosticString(this);");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
    }

    private void GenerateSerializationMethods(StringBuilder sourceBuilder, List<ProtoMember> members, string className)
    {
        // Generate WriteTo method
        sourceBuilder.AppendLine("        public void WriteTo(CodedOutputStream output)");
        sourceBuilder.AppendLine("        {");
        
        foreach (var member in members)
        {
            var fieldName = ToCamelCase(member.Name) + "_";
            sourceBuilder.AppendLine($"            if ({member.Name} != null) {{");
            sourceBuilder.AppendLine($"                output.WriteTag({member.Tag}, {GetWireType(member.Type)});");
            sourceBuilder.AppendLine($"                {GetWriteExpression(member.Type, fieldName, "output")};");
            sourceBuilder.AppendLine("            }");
        }
        
        sourceBuilder.AppendLine("            if (_unknownFields != null) _unknownFields.WriteTo(output);");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        // Generate CalculateSize method
        sourceBuilder.AppendLine("        public int CalculateSize()");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            int size = 0;");
        
        foreach (var member in members)
        {
            sourceBuilder.AppendLine($"            if ({member.Name} != null) size += {GetSizeExpression(member.Type, member.Name, member.Tag)};");
        }
        
        sourceBuilder.AppendLine("            if (_unknownFields != null) size += _unknownFields.CalculateSize();");
        sourceBuilder.AppendLine("            return size;");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        // Generate MergeFrom methods (simplified for now)
        sourceBuilder.AppendLine($"        public void MergeFrom({className} other)");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            if (other == null) return;");
        foreach (var member in members)
        {
            sourceBuilder.AppendLine($"            if (other.{member.Name} != null) {member.Name} = other.{member.Name};");
        }
        sourceBuilder.AppendLine("            _unknownFields = UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        sourceBuilder.AppendLine("        public void MergeFrom(CodedInputStream input)");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            uint tag;");
        sourceBuilder.AppendLine("            while ((tag = input.ReadTag()) != 0) {");
        sourceBuilder.AppendLine("                switch(tag) {");
        
        foreach (var member in members)
        {
            sourceBuilder.AppendLine($"                    case {member.Tag}:");
            sourceBuilder.AppendLine($"                        {member.Name} = {GetReadExpression(member.Type, "input")};");
            sourceBuilder.AppendLine("                        break;");
        }
        
        sourceBuilder.AppendLine("                    default:");
        sourceBuilder.AppendLine("                        _unknownFields = UnknownFieldSet.MergeFieldFrom(_unknownFields, input);");
        sourceBuilder.AppendLine("                        break;");
        sourceBuilder.AppendLine("                }");
        sourceBuilder.AppendLine("            }");
        sourceBuilder.AppendLine("        }");
    }

    // Helper methods for type conversion and code generation
    
    private string GetProtobufTypeName(ITypeSymbol type)
    {
        if (type.OriginalDefinition?.SpecialType == SpecialType.System_Nullable_T)
        {
            var underlyingType = ((INamedTypeSymbol)type).TypeArguments[0];
            return GetProtobufTypeName(underlyingType);
        }
        
        return type.SpecialType switch
        {
            SpecialType.System_String => "string",
            SpecialType.System_Int32 => "int",
            SpecialType.System_Int64 => "long",
            SpecialType.System_UInt32 => "uint",
            SpecialType.System_UInt64 => "ulong",
            SpecialType.System_Boolean => "bool",
            SpecialType.System_Double => "double",
            SpecialType.System_Single => "float",
            _ when type.Name == "DateTime" => "Timestamp",
            _ when type.Name == "TimeSpan" => "Duration",
            _ when IsCollectionType(type) => GetCollectionTypeName(type),
            _ => type.ToDisplayString()
        };
    }

    private string GetPublicTypeName(ITypeSymbol type)
    {
        return type.ToDisplayString();
    }

    private string GetDefaultValue(ITypeSymbol type)
    {
        if (IsCollectionType(type))
        {
            return $" = new {GetCollectionTypeName(type)}()";
        }
        
        return type.SpecialType switch
        {
            SpecialType.System_String => " = \"\"",
            SpecialType.System_Boolean => "",
            _ when type.CanBeReferencedByName && !type.IsValueType => "",
            _ => ""
        };
    }

    private bool IsCollectionType(ITypeSymbol type)
    {
        var typeName = type.ToDisplayString();
        return typeName.StartsWith("System.Collections.Generic.IList<") ||
               typeName.StartsWith("System.Collections.Generic.IDictionary<") ||
               typeName.StartsWith("System.Collections.Generic.Dictionary<") ||
               typeName.StartsWith("System.Collections.Concurrent.ConcurrentDictionary<");
    }

    private bool IsMessageType(ITypeSymbol type)
    {
        return !type.IsValueType && type.SpecialType == SpecialType.None && 
               !type.ToDisplayString().StartsWith("System.");
    }

    private string GetCollectionTypeName(ITypeSymbol type)
    {
        var typeName = type.ToDisplayString();
        if (typeName.StartsWith("System.Collections.Generic.IList<"))
        {
            var elementType = ((INamedTypeSymbol)type).TypeArguments[0].ToDisplayString();
            return $"RepeatedField<{elementType}>";
        }
        else if (typeName.Contains("Dictionary"))
        {
            var keyType = ((INamedTypeSymbol)type).TypeArguments[0].ToDisplayString();
            var valueType = ((INamedTypeSymbol)type).TypeArguments[1].ToDisplayString();
            return $"MapField<{keyType}, {valueType}>";
        }
        return typeName;
    }

    private string GetFieldAccessor(ITypeSymbol type, string fieldName)
    {
        return fieldName;
    }

    private string GetFieldSetter(ITypeSymbol type, string fieldName, string value)
    {
        return $"{fieldName} = {value};";
    }

    private string GetWireType(ITypeSymbol type)
    {
        return "WireFormat.WireType.LengthDelimited"; // Simplified
    }

    private string GetWriteExpression(ITypeSymbol type, string fieldName, string output)
    {
        return $"output.WriteString({fieldName})"; // Simplified
    }

    private string GetSizeExpression(ITypeSymbol type, string fieldName, int tag)
    {
        return $"CodedOutputStream.ComputeStringSize({tag}, {fieldName})"; // Simplified
    }

    private string GetReadExpression(ITypeSymbol type, string input)
    {
        return $"{input}.ReadString()"; // Simplified
    }

    private string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        return char.ToLowerInvariant(name[0]) + name.Substring(1);
    }

    private class ProtoMember
    {
        public string Name { get; set; } = "";
        public ITypeSymbol Type { get; set; } = null!;
        public int Tag { get; set; }
        public IPropertySymbol Property { get; set; } = null!;
    }
}