using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Dameng.Protobuf.Extension.Generator;

[Generator]
public class PbMessageGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context) { }

    private static string GetPartialTypeDeclaration(INamedTypeSymbol typeSymbol)
    {
        var typeName = typeSymbol.Name;

        // Check if it's a record
        if (typeSymbol.IsRecord)
        {
            // Check if it's a record struct
            if (typeSymbol.IsValueType)
            {
                return $"partial record struct {typeName}";
            }
            else
            {
                return $"partial record {typeName}";
            }
        }
        // Check if it's a struct (but not a record struct)
        else if (typeSymbol.IsValueType)
        {
            // Check if it's readonly struct by looking at the declaration
            // Note: We can't easily detect readonly from INamedTypeSymbol, but we'll generate regular partial struct
            return $"partial struct {typeName}";
        }
        // Default to class
        else
        {
            return $"partial class {typeName}";
        }
    }

    public void Execute(GeneratorExecutionContext context)
    {
        foreach (var syntaxTree in context.Compilation.SyntaxTrees)
        {
            var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
            foreach (var typeDeclaration in syntaxTree.GetRoot().DescendantNodesAndSelf())
            {
                if (
                    typeDeclaration
                    is not ClassDeclarationSyntax
                        and not StructDeclarationSyntax
                        and not RecordDeclarationSyntax
                )
                    continue;
                var targetType =
                    semanticModel.GetDeclaredSymbol(typeDeclaration) as INamedTypeSymbol;

                if (targetType is null)
                {
                    continue;
                }

                var attributes = targetType.GetAttributes();

                // Handle GenSepParsable attribute FIRST and independently
                var genParsableAttribute = attributes.FirstOrDefault(attribute =>
                    attribute
                        .AttributeClass!.ToDisplayString()
                        .Equals("Dameng.Protobuf.Extension.ProtoContractAttribute")
                );

                if (genParsableAttribute is null)
                    continue;
                StringBuilder genClassCodeBuilder = new StringBuilder();
                genClassCodeBuilder.AppendLine(
                    $$"""
                    //------------------------------------------------------------------------------ 
                    // <auto-generated> 
                    // This code was generated at {{DateTimeOffset.Now:O}}. 
                    // Generator: {{nameof(PbMessageGenerator)}}
                    // Assembly: {{typeof(PbMessageGenerator).Assembly.FullName}}
                    // </auto-generated> 
                    //------------------------------------------------------------------------------

                    using System;
                    using Dameng.SepEx;

                    namespace {{targetType.ContainingNamespace.ToDisplayString()}};

                    """
                );

                var (getHeaderCode, initCode, writeCode) = GeneratePropertyCode(
                    targetType,
                    context
                );

                var classMemberBody = $$"""
                        public static {{targetType.ToDisplayString()}} Read(nietras.SeparatedValues.SepReader reader, nietras.SeparatedValues.SepReader.Row readRow) 
                        {
                    {{initCode}}
                        }
                        public static void Write(nietras.SeparatedValues.SepWriter writer,nietras.SeparatedValues.SepWriter.Row writeRow, {{targetType.ToDisplayString()}} value)
                        {
                    {{writeCode}}
                        }
                        
                        public static IEnumerable<string> GetHeaders()
                        {
                    {{getHeaderCode}}
                        }
                    """;

                var partialTypeDeclaration = GetPartialTypeDeclaration(targetType);

                if (targetType.ContainingType is null)
                {
                    // Top-level class - use original logic
                    genClassCodeBuilder.Append(
                        $$"""
                        {{partialTypeDeclaration}} : ISepParsable<{{targetType.ToDisplayString()}}>
                        {
                        {{classMemberBody}}
                        }
                        """
                    );
                }
                else
                {
                    // Nested class - build proper containment structure
                    genClassCodeBuilder.Append(
                        GenerateNestedClassStructure(targetType, classMemberBody)
                    );
                }

                // Just change the filename for now as a test
                var fileName = targetType.ContainingType is not null
                    ? targetType.ToDisplayString().Replace(".", "_") + ".SepParsable.g.cs"
                    : targetType.Name + ".SepParsable.g.cs";

                context.AddSource(
                    fileName,
                    SourceText.From(genClassCodeBuilder.ToString(), Encoding.UTF8)
                );
            }
        }
    }

    private static string GenerateNestedClassStructure(
        INamedTypeSymbol targetType,
        string classMemberBody
    )
    {
        // Build the list of containing classes from outermost to innermost
        var containers = new List<INamedTypeSymbol>();
        var current = targetType.ContainingType;
        while (current is not null)
        {
            containers.Add(current);
            current = current.ContainingType;
        }

        // Reverse to get from outermost to innermost
        containers.Reverse();

        // Build the nested structure
        var nestedTypeDeclaration = GetPartialTypeDeclaration(targetType);
        var targetClassDef = $$"""
            {{nestedTypeDeclaration}} : IMessage<{{targetType.ToDisplayString()}}>
            {
            {{classMemberBody}}
            }
            """;

        // Wrap in container classes
        var result = targetClassDef;
        for (int i = containers.Count - 1; i >= 0; i--)
        {
            var container = containers[i];
            var containerAccessibility =
                container.DeclaredAccessibility is Accessibility.Public ? "public" : "internal";
            var indent = new string(' ', (containers.Count - 1 - i) * 4);

            // Add indentation to current result
            var indentedResult = string.Join(
                "\n",
                result
                    .Split('\n')
                    .Select(line => string.IsNullOrWhiteSpace(line) ? line : "    " + line)
            );

            result = $$"""
                {{indent}}{{containerAccessibility}} partial class {{container.Name}}
                {{indent}}{
                {{indentedResult}}
                {{indent}}}
                """;
        }

        return result;
    }

    internal static (string getHeaderCode, string ReadCode, string WriteCode) GeneratePropertyCode(
        INamedTypeSymbol targetType,
        GeneratorExecutionContext context
    )
    {
        var spanParsableInterface = context.Compilation.GetTypeByMetadataName(
            "System.ISpanParsable`1"
        );
        if (spanParsableInterface is null)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "SP001",
                        "Missing ISpanParsable",
                        "The ISpanParsable interface is not available. Ensure you are targeting .NET 6 or later.",
                        "Usage",
                        DiagnosticSeverity.Error,
                        true
                    ),
                    Location.None
                )
            );

            throw new Exception(
                "The ISpanParsable interface is not available. Ensure you are targeting .NET 6 or later."
            );
        }

        var parsableInterface = context.Compilation.GetTypeByMetadataName("System.ISpanParsable`1");
        if (parsableInterface is null)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "SP001",
                        "Missing ISpanParsable",
                        "The ISpanParsable interface is not available. Ensure you are targeting .NET 6 or later.",
                        "Usage",
                        DiagnosticSeverity.Error,
                        true
                    ),
                    Location.None
                )
            );

            throw new Exception(
                "The ISpanParsable interface is not available. Ensure you are targeting .NET 6 or later."
            );
        }

        var spanFormattableInterface = context.Compilation.GetTypeByMetadataName(
            "System.ISpanFormattable"
        );
        if (spanFormattableInterface is null)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "SP001",
                        "Missing ISpanFormattable",
                        "The ISpanFormattable interface is not available. Ensure you are targeting .NET 6 or later.",
                        "Usage",
                        DiagnosticSeverity.Error,
                        true
                    ),
                    Location.None
                )
            );

            throw new Exception(
                "The ISpanFormattable interface is not available. Ensure you are targeting .NET 6 or later."
            );
        }

        StringBuilder propertyReadCodeBuilder = new StringBuilder();
        StringBuilder propertyWriteCodeBuilder = new StringBuilder();
        StringBuilder getHeadersCodeBuilder = new StringBuilder();

        bool hasPrimaryConstructor =
            targetType.InstanceConstructors.FirstOrDefault(c =>
                c.IsImplicitlyDeclared == false && c.Parameters.Length > 0
            )
                is not null;

        int propertyIndex = 0;
        foreach (var member in targetType.GetMembers())
        {
            string memberName;
            bool isReadable = true;
            bool isWritable = true;
            ITypeSymbol memberType;
            if (member is IPropertySymbol { IsStatic: false, IsImplicitlyDeclared: false } property)
            {
                memberName = property.Name;
                memberType = property.Type;
                isReadable = !property.IsWriteOnly;
                isWritable = !property.IsReadOnly;
            }
            else if (member is IFieldSymbol { IsStatic: false, IsImplicitlyDeclared: false } field)
            {
                memberName = field.Name;
                memberType = field.Type;
            }
            else
            {
                continue;
            }

            if (
                member
                    .GetAttributes()
                    .FirstOrDefault(o =>
                        o.AttributeClass?.ToDisplayString()
                            .Contains("Dameng.SepEx.SepColumnIgnoreAttribute") == true
                    )
                is not null
            )
            {
                propertyReadCodeBuilder.AppendLine("            // Ignored: " + memberName);
                propertyWriteCodeBuilder.AppendLine("        // Ignored: " + memberName);
                continue;
            }

            // Check if it's a nullable type first
            bool isNullable = false;
            ITypeSymbol underlyingType = memberType;
            if (memberType.OriginalDefinition?.SpecialType == SpecialType.System_Nullable_T)
            {
                isNullable = true;
                underlyingType = ((INamedTypeSymbol)memberType).TypeArguments[0];
            }

            // Check if it's an enum type
            bool isEnum = underlyingType.TypeKind == TypeKind.Enum;

            var parsableDefine = underlyingType.AllInterfaces.FirstOrDefault(i =>
                SymbolEqualityComparer.Default.Equals(i.OriginalDefinition, parsableInterface)
            );

            var spanParsableDefine = underlyingType.AllInterfaces.FirstOrDefault(i =>
                SymbolEqualityComparer.Default.Equals(i.OriginalDefinition, parsableInterface)
            );
            string tryReadMethodName;
            if (isEnum)
            {
                tryReadMethodName = "TryReadEnum";
            }
            else if (
                spanParsableDefine is not null
                && spanParsableDefine.TypeArguments.Length == 1
                && SymbolEqualityComparer.Default.Equals(
                    spanParsableDefine.TypeArguments[0],
                    underlyingType
                )
            )
            {
                tryReadMethodName = "TryReadSpanParsable";
            }
            else if (
                parsableDefine is not null
                && parsableDefine.TypeArguments.Length == 1
                && SymbolEqualityComparer.Default.Equals(
                    parsableDefine.TypeArguments[0],
                    underlyingType
                )
            )
            {
                tryReadMethodName = "TryReadSpanParsable";
            }
            else
            {
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "SP002",
                            "Unsupported Property Type",
                            $"The property '{memberName}' of type '{memberType}' is not support ISpanParsable<TSelf>/IParsable<TSelf>.",
                            "Usage",
                            DiagnosticSeverity.Error,
                            true
                        ),
                        Location.None
                    )
                );
                break;
            }
            propertyIndex++;

            var defaultValueAttributeValue = member
                .GetAttributes()
                .FirstOrDefault(o =>
                    o.AttributeClass?.ToDisplayString()
                        .Equals("Dameng.SepEx.SepDefaultValueAttribute") == true
                )
                ?.ConstructorArguments.FirstOrDefault()
                .Value;
            var defaultValue =
                memberType.SpecialType == SpecialType.System_String
                    ? defaultValueAttributeValue is null
                        ? "string.Empty"
                        : $"\"{defaultValueAttributeValue}\""
                    : isNullable
                        ? defaultValueAttributeValue is null
                            ? "null"
                            : $"({underlyingType.ToDisplayString()}?){defaultValueAttributeValue}"
                        : defaultValueAttributeValue is null
                            ? "default(" + memberType.ToDisplayString() + ")"
                            : defaultValueAttributeValue.ToString();

            var columnName =
                member
                    .GetAttributes()
                    .FirstOrDefault(o =>
                        o.AttributeClass?.ToDisplayString()
                            .Equals("Dameng.SepEx.SepColumnNameAttribute") == true
                    )
                    ?.ConstructorArguments.FirstOrDefault()
                    .Value?.ToString() ?? memberName;
            var columnIndex = member
                .GetAttributes()
                .FirstOrDefault(o =>
                    o.AttributeClass?.ToDisplayString()
                        .Equals("Dameng.SepEx.SepColumnIndexAttribute") == true
                )
                ?.ConstructorArguments.FirstOrDefault()
                .Value?.ToString();
            var format = member
                .GetAttributes()
                .FirstOrDefault(o =>
                    o.AttributeClass?.ToDisplayString()
                        .Equals("Dameng.SepEx.SepColumnFormatAttribute") == true
                )
                ?.ConstructorArguments.FirstOrDefault()
                .Value?.ToString();

            string readColKey = columnIndex ?? $"\"{columnName}\"";
            string writeColKey = $"\"{columnName}\"";

            if (isWritable)
            {
                var valueCode =
                    underlyingType.SpecialType == SpecialType.System_String
                        ? $"Dameng.SepEx.Parser.UnescapeSepField(readRow[{readColKey}].Span).ToString()"
                        : $"Dameng.SepEx.Parser.{tryReadMethodName}<{underlyingType.ToDisplayString()}>(reader,readRow,{readColKey},\"{format}\",out var v{propertyIndex})?v{propertyIndex}:{defaultValue}";

                propertyReadCodeBuilder.AppendLine(
                    hasPrimaryConstructor
                        ? $"            {valueCode},"
                        : $"            {memberName} = {valueCode},"
                );
            }

            if (isReadable)
            {
                string valueString;
                if (underlyingType.SpecialType == SpecialType.System_String)
                {
                    if (isNullable)
                    {
                        valueString = $"value.{memberName}?.ToString() ?? string.Empty";
                    }
                    else
                    {
                        valueString = $"value.{memberName}";
                    }
                }
                else
                {
                    if (isNullable)
                    {
                        // For now, always use Set with ToString for nullable types to avoid Format constraints
                        valueString = string.IsNullOrWhiteSpace(format)
                            ? $"value.{memberName}?.ToString() ?? string.Empty"
                            : $"value.{memberName}?.ToString(\"{format}\") ?? string.Empty";
                    }
                    else
                    {
                        var spanFormattableDefine = underlyingType.AllInterfaces.FirstOrDefault(i =>
                            SymbolEqualityComparer.Default.Equals(
                                i.OriginalDefinition,
                                spanFormattableInterface
                            )
                        );
                        valueString = string.IsNullOrWhiteSpace(format)
                            ? $"value.{memberName}.ToString()"
                            : $"value.{memberName}.ToString(\"{format}\")";
                    }
                }

                propertyWriteCodeBuilder.AppendLine(
                    $"        writeRow[{writeColKey}].Set(Dameng.SepEx.Parser.EscapeSepField({valueString},writer.Spec.Sep.Separator));"
                );
                getHeadersCodeBuilder.AppendLine($"        yield return {writeColKey};");
            }
        }

        var instanceInitCode = hasPrimaryConstructor
            ? $$"""
                        // PrimaryConstructor:{{hasPrimaryConstructor}}
                        return new {{targetType.ToDisplayString()}}(
                {{propertyReadCodeBuilder.ToString().TrimEnd().TrimEnd(',')}}
                        );
                """
            : $$"""
                        // PrimaryConstructor:{{hasPrimaryConstructor}}
                        return new {{targetType.ToDisplayString()}}() 
                        {
                {{propertyReadCodeBuilder.ToString().TrimEnd().TrimEnd(',')}}
                        };
                """;
        return (
            getHeadersCodeBuilder.ToString().TrimEnd(),
            instanceInitCode,
            propertyWriteCodeBuilder.ToString().TrimEnd()
        );
    }
}
