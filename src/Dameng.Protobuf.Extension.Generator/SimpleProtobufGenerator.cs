using System.Text;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Dameng.Protobuf.Extension.Generator;

[Generator]
public class SimpleProtobufGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context) { }

    public void Execute(GeneratorExecutionContext context)
    {
        foreach (var syntaxTree in context.Compilation.SyntaxTrees)
        {
            var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
            
            foreach (var node in syntaxTree.GetRoot().DescendantNodesAndSelf())
            {
                if (node is not ClassDeclarationSyntax classDeclaration)
                    continue;

                var targetType = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
                if (targetType is null)
                    continue;

                // Look for ProtoContract attribute
                var hasProtoContract = false;
                foreach (var attr in targetType.GetAttributes())
                {
                    if (attr.AttributeClass?.ToDisplayString() == "Dameng.Protobuf.Extension.ProtoContractAttribute")
                    {
                        hasProtoContract = true;
                        break;
                    }
                }

                if (!hasProtoContract)
                    continue;

                // Generate the complete protobuf message implementation with partial properties
                var sourceCode = GenerateCompleteProtobufMessage(targetType);
                var fileName = $"{targetType.Name}.Generated.cs";
                context.AddSource(fileName, SourceText.From(sourceCode, Encoding.UTF8));
            }
        }
    }

    private string GenerateCompleteProtobufMessage(INamedTypeSymbol targetType)
    {
        var namespaceName = targetType.ContainingNamespace.ToDisplayString();
        var className = targetType.Name;
        var protoMembers = GetProtoMembers(targetType);

        var sourceBuilder = new StringBuilder();
        
        sourceBuilder.AppendLine("// <auto-generated>");
        sourceBuilder.AppendLine("//     Generated by SimpleProtobufGenerator for partial properties");
        sourceBuilder.AppendLine("// </auto-generated>");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("using System;");
        sourceBuilder.AppendLine("using System.Collections.Generic;");
        sourceBuilder.AppendLine("using System.Collections.Concurrent;");
        sourceBuilder.AppendLine("using System.Linq;");
        sourceBuilder.AppendLine("using Google.Protobuf;");
        sourceBuilder.AppendLine("using Google.Protobuf.Collections;");
        sourceBuilder.AppendLine("using Google.Protobuf.Reflection;");
        sourceBuilder.AppendLine("using Google.Protobuf.WellKnownTypes;");
        sourceBuilder.AppendLine();
        
        sourceBuilder.AppendLine($"namespace {namespaceName}");
        sourceBuilder.AppendLine("{");
        
        // Generate the partial class that implements IMessage and provides partial property implementations
        sourceBuilder.AppendLine($"    partial class {className} : IMessage<{className}>, IPbMessageParser<{className}>"); 
        sourceBuilder.AppendLine("    {");
        
        // Note: Properties are already declared with partial keyword in the user's class
        // We don't generate property implementations since partial properties are not yet supported
        // Instead, the user's class declarations already include get; set; implementations
        
        // Generate static parser
        sourceBuilder.AppendLine($"        private static readonly MessageParser<{className}> _parser = new MessageParser<{className}>(() => new {className}());");
        sourceBuilder.AppendLine($"        public static MessageParser<{className}> Parser {{ get {{ return _parser; }} }}");
        sourceBuilder.AppendLine();
        
        // Add descriptor (simplified)
        sourceBuilder.AppendLine("        public static MessageDescriptor Descriptor => throw new NotImplementedException(\"Descriptor not yet implemented\");");
        sourceBuilder.AppendLine("        MessageDescriptor IMessage.Descriptor => Descriptor;");
        sourceBuilder.AppendLine();
        
        // Add unknown fields
        sourceBuilder.AppendLine("        private UnknownFieldSet _unknownFields;");
        sourceBuilder.AppendLine();
        
        // Default constructor that initializes collections
        sourceBuilder.AppendLine($"        public {className}()");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            // Collections are initialized in the property declarations");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        // Generate copy constructor
        sourceBuilder.AppendLine($"        public {className}({className} other) : this()");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            if (other == null) return;");
        sourceBuilder.AppendLine();
        // TODO: Copy member fields
        sourceBuilder.AppendLine("            _unknownFields = UnknownFieldSet.Clone(other._unknownFields);");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        // Generate Clone method
        sourceBuilder.AppendLine($"        public {className} Clone()");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine($"            return new {className}(this);");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        // Generate Equals methods
        sourceBuilder.AppendLine("        public override bool Equals(object other)");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine($"            return Equals(other as {className});");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        sourceBuilder.AppendLine($"        public bool Equals({className} other)");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            if (ReferenceEquals(other, null)) return false;");
        sourceBuilder.AppendLine("            if (ReferenceEquals(other, this)) return true;");
        sourceBuilder.AppendLine();
        // TODO: Compare member fields
        sourceBuilder.AppendLine("            return Equals(_unknownFields, other._unknownFields);");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        // Generate helper methods for collections
        GenerateHelperMethods(sourceBuilder);
        
        // Generate GetHashCode
        sourceBuilder.AppendLine("        public override int GetHashCode()");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            int hash = 1;");
        // TODO: Hash member fields
        sourceBuilder.AppendLine("            if (_unknownFields != null) hash ^= _unknownFields.GetHashCode();");
        sourceBuilder.AppendLine("            return hash;");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        // Generate ToString
        sourceBuilder.AppendLine("        public override string ToString()");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine($"            return $\"{className} with {{GetType().Name}}\";");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        // Generate basic serialization methods - simplified for now
        sourceBuilder.AppendLine("        public void WriteTo(CodedOutputStream output)");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            if (_unknownFields != null)");
        sourceBuilder.AppendLine("                _unknownFields.WriteTo(output);");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        sourceBuilder.AppendLine("        public int CalculateSize()");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            int size = 0;");
        sourceBuilder.AppendLine("            if (_unknownFields != null)");
        sourceBuilder.AppendLine("                size += _unknownFields.CalculateSize();");
        sourceBuilder.AppendLine("            return size;");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        sourceBuilder.AppendLine($"        public void MergeFrom({className} other)");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            if (other == null) return;");
        sourceBuilder.AppendLine("            _unknownFields = UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        sourceBuilder.AppendLine("        public void MergeFrom(CodedInputStream input)");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            uint tag;");
        sourceBuilder.AppendLine("            while ((tag = input.ReadTag()) != 0)");
        sourceBuilder.AppendLine("            {");
        sourceBuilder.AppendLine("                _unknownFields = UnknownFieldSet.MergeFieldFrom(_unknownFields, input);");
        sourceBuilder.AppendLine("            }");
        sourceBuilder.AppendLine("        }");
        
        sourceBuilder.AppendLine("    }");
        sourceBuilder.AppendLine("}");
        
        return sourceBuilder.ToString();
    }

    private List<ProtoMember> GetProtoMembers(INamedTypeSymbol targetType)
    {
        var members = new List<ProtoMember>();
        
        foreach (var member in targetType.GetMembers())
        {
            if (!(member is IPropertySymbol property) || property.IsStatic)
                continue;
                
            AttributeData protoMemberAttr = null;
            foreach (var attr in property.GetAttributes())
            {
                if (attr.AttributeClass?.ToDisplayString() == "Dameng.Protobuf.Extension.ProtoMemberAttribute")
                {
                    protoMemberAttr = attr;
                    break;
                }
            }
                
            if (protoMemberAttr == null)
                continue;
                
            var tag = (int)protoMemberAttr.ConstructorArguments[0].Value;
            members.Add(new ProtoMember
            {
                Name = property.Name,
                Type = property.Type,
                Tag = tag
            });
        }
        
        return members.OrderBy(m => m.Tag).ToList();
    }

    private class ProtoMember
    {
        public string Name { get; set; } = "";
        public ITypeSymbol Type { get; set; } = null!;
        public int Tag { get; set; }
    }

    private string GetFieldType(ProtoMember member)
    {
        var typeStr = member.Type.ToDisplayString();
        
        // Handle collections - they need explicit initialization
        if (typeStr.Contains("IList<") || typeStr.Contains("IDictionary<") || typeStr.Contains("Dictionary<") || typeStr.Contains("ConcurrentDictionary<"))
        {
            return typeStr;
        }
        
        return typeStr;
    }

    private bool NeedsCollectionInitialization(ProtoMember member)
    {
        var typeStr = member.Type.ToDisplayString();
        return typeStr.Contains("IList<") || typeStr.Contains("IDictionary<") || typeStr.Contains("Dictionary<") || typeStr.Contains("ConcurrentDictionary<");
    }

    private string GetCollectionInitialization(ProtoMember member)
    {
        var typeStr = member.Type.ToDisplayString();
        
        if (typeStr.Contains("IList<"))
        {
            // Extract the generic type from IList<T>
            var genericStart = typeStr.IndexOf('<');
            var genericEnd = typeStr.LastIndexOf('>');
            var genericType = typeStr.Substring(genericStart + 1, genericEnd - genericStart - 1);
            return $"new List<{genericType}>()";
        }
        
        if (typeStr.Contains("IDictionary<"))
        {
            // Extract the generic types from IDictionary<K,V>
            var genericPart = typeStr.Substring(typeStr.IndexOf('<') + 1, typeStr.LastIndexOf('>') - typeStr.IndexOf('<') - 1);
            return $"new Dictionary<{genericPart}>()";
        }
        
        if (typeStr.Contains("Dictionary<") && !typeStr.Contains("ConcurrentDictionary<"))
        {
            // Extract the generic types from Dictionary<K,V>
            var genericPart = typeStr.Substring(typeStr.IndexOf('<') + 1, typeStr.LastIndexOf('>') - typeStr.IndexOf('<') - 1);
            return $"new Dictionary<{genericPart}>()";
        }
        
        if (typeStr.Contains("ConcurrentDictionary<"))
        {
            // Extract the generic types from ConcurrentDictionary<K,V>
            var genericPart = typeStr.Substring(typeStr.IndexOf('<') + 1, typeStr.LastIndexOf('>') - typeStr.IndexOf('<') - 1);
            return $"new ConcurrentDictionary<{genericPart}>()";
        }
        
        return "default";
    }

    private string GenerateCopyLine(ProtoMember member)
    {
        var memberName = member.Name;
        var typeStr = member.Type.ToDisplayString();
        
        if (typeStr.Contains("IList<"))
        {
            return $"            {memberName} = other.{memberName} != null ? new List<{GetGenericType(typeStr)}>(other.{memberName}) : new List<{GetGenericType(typeStr)}>();";
        }
        
        if (typeStr.Contains("IDictionary<") || typeStr.Contains("Dictionary<") && !typeStr.Contains("ConcurrentDictionary<"))
        {
            var genericPart = GetGenericTypePair(typeStr);
            return $"            {memberName} = new Dictionary<{genericPart}>(other.{memberName});";
        }
        
        if (typeStr.Contains("ConcurrentDictionary<"))
        {
            var genericPart = GetGenericTypePair(typeStr);
            return $"            {memberName} = new ConcurrentDictionary<{genericPart}>(other.{memberName});";
        }
        
        if (typeStr == "byte[]")
        {
            return $"            {memberName} = other.{memberName};";
        }
        
        if (typeStr.Contains("CsTestMessage"))
        {
            return $"            {memberName} = other.{memberName}?.Clone();";
        }
        
        return $"            {memberName} = other.{memberName};";
    }

    private string GenerateEqualsLine(ProtoMember member)
    {
        var memberName = member.Name;
        var typeStr = member.Type.ToDisplayString();
        
        if (typeStr.Contains("IList<"))
        {
            return $"            if (!ListsEqual({memberName}, other.{memberName})) return false;";
        }
        
        if (typeStr.Contains("IDictionary<") || typeStr.Contains("Dictionary<") || typeStr.Contains("ConcurrentDictionary<"))
        {
            if (typeStr.Contains("ConcurrentDictionary<"))
            {
                return $"            if (!DictionariesEqual({memberName}.ToDictionary(kv => kv.Key, kv => kv.Value), other.{memberName}.ToDictionary(kv => kv.Key, kv => kv.Value))) return false;";
            }
            return $"            if (!DictionariesEqual({memberName}, other.{memberName})) return false;";
        }
        
        if (typeStr == "byte[]")
        {
            return $"            if (!BytesFieldsEqual({memberName}, other.{memberName})) return false;";
        }
        
        return $"            if (!object.Equals({memberName}, other.{memberName})) return false;";
    }

    private string GenerateHashCodeLine(ProtoMember member)
    {
        var memberName = member.Name;
        var typeStr = member.Type.ToDisplayString();
        
        if (typeStr.Contains("IList<"))
        {
            return $"            if ({memberName} != null) foreach (var item in {memberName}) hash ^= (item?.GetHashCode() ?? 0);";
        }
        
        if (typeStr.Contains("IDictionary<") || typeStr.Contains("Dictionary<") || typeStr.Contains("ConcurrentDictionary<"))
        {
            return $"            if ({memberName} != null) hash ^= {memberName}.GetHashCode();";
        }
        
        return $"            if ({memberName} != null) hash ^= {memberName}.GetHashCode();";
    }

    private void GenerateHelperMethods(StringBuilder sourceBuilder)
    {
        sourceBuilder.AppendLine("        private static bool ListsEqual<T>(IList<T> a, IList<T> b)");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            if (a == null && b == null) return true;");
        sourceBuilder.AppendLine("            if (a == null || b == null) return false;");
        sourceBuilder.AppendLine("            if (a.Count != b.Count) return false;");
        sourceBuilder.AppendLine("            for (int i = 0; i < a.Count; i++)");
        sourceBuilder.AppendLine("            {");
        sourceBuilder.AppendLine("                if (!object.Equals(a[i], b[i])) return false;");
        sourceBuilder.AppendLine("            }");
        sourceBuilder.AppendLine("            return true;");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        sourceBuilder.AppendLine("        private static bool DictionariesEqual<K, V>(IDictionary<K, V> a, IDictionary<K, V> b)");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            if (a == null && b == null) return true;");
        sourceBuilder.AppendLine("            if (a == null || b == null) return false;");
        sourceBuilder.AppendLine("            if (a.Count != b.Count) return false;");
        sourceBuilder.AppendLine("            foreach (var kv in a)");
        sourceBuilder.AppendLine("            {");
        sourceBuilder.AppendLine("                if (!b.TryGetValue(kv.Key, out var value) || !object.Equals(kv.Value, value))");
        sourceBuilder.AppendLine("                    return false;");
        sourceBuilder.AppendLine("            }");
        sourceBuilder.AppendLine("            return true;");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        sourceBuilder.AppendLine("        private static bool BytesFieldsEqual(byte[] a, byte[] b)");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            if (a == null && b == null) return true;");
        sourceBuilder.AppendLine("            if (a == null || b == null) return false;");
        sourceBuilder.AppendLine("            if (a.Length != b.Length) return false;");
        sourceBuilder.AppendLine("            for (int i = 0; i < a.Length; i++)");
        sourceBuilder.AppendLine("            {");
        sourceBuilder.AppendLine("                if (a[i] != b[i]) return false;");
        sourceBuilder.AppendLine("            }");
        sourceBuilder.AppendLine("            return true;");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
    }

    private string GetGenericType(string typeStr)
    {
        var genericStart = typeStr.IndexOf('<');
        var genericEnd = typeStr.LastIndexOf('>');
        return typeStr.Substring(genericStart + 1, genericEnd - genericStart - 1);
    }

    private string GetGenericTypePair(string typeStr)
    {
        var genericStart = typeStr.IndexOf('<');
        var genericEnd = typeStr.LastIndexOf('>');
        return typeStr.Substring(genericStart + 1, genericEnd - genericStart - 1);
    }
}