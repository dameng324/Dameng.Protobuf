using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Dameng.Protobuf.Extension.Generator;

[Generator]
public class SimpleProtobufGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context) { }

    public void Execute(GeneratorExecutionContext context)
    {
        // DEBUG: Generate a test file to confirm this generator is running
        context.AddSource("DebugTestFile.cs", SourceText.From(@"// DEBUG: This file proves the generator is active
namespace DebugTest 
{ 
    public class TestGeneratedClass { } 
}", Encoding.UTF8));
        return; // Don't generate anything else
        
        foreach (var syntaxTree in context.Compilation.SyntaxTrees)
        {
            var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
            
            foreach (var node in syntaxTree.GetRoot().DescendantNodesAndSelf())
            {
                if (node is not ClassDeclarationSyntax classDeclaration)
                    continue;

                var targetType = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
                if (targetType is null)
                    continue;

                // Look for ProtoContract attribute
                var hasProtoContract = false;
                foreach (var attr in targetType.GetAttributes())
                {
                    if (attr.AttributeClass?.ToDisplayString() == "Dameng.Protobuf.Extension.ProtoContractAttribute")
                    {
                        hasProtoContract = true;
                        break;
                    }
                }

                if (!hasProtoContract)
                    continue;

                // Generate the minimal protobuf message implementation
                var sourceCode = GenerateMinimalProtobufMessage(targetType);
                var fileName = $"{targetType.Name}.Generated.cs";
                context.AddSource(fileName, SourceText.From(sourceCode, Encoding.UTF8));
            }
        }
    }

    private string GenerateMinimalProtobufMessage(INamedTypeSymbol targetType)
    {
        var namespaceName = targetType.ContainingNamespace.ToDisplayString();
        var className = targetType.Name;

        var sourceBuilder = new StringBuilder();
        
        sourceBuilder.AppendLine("// <auto-generated>");
        sourceBuilder.AppendLine("//     Generated by SimpleProtobufGeneratorClean - minimal implementation");
        sourceBuilder.AppendLine("// </auto-generated>");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("using System;");
        sourceBuilder.AppendLine("using Google.Protobuf;");
        sourceBuilder.AppendLine("using Google.Protobuf.Reflection;");
        sourceBuilder.AppendLine();
        
        sourceBuilder.AppendLine($"namespace {namespaceName}");
        sourceBuilder.AppendLine("{");
        
        // Generate the partial class that implements IMessage
        sourceBuilder.AppendLine($"    partial class {className} : IMessage<{className}>, IPbMessageParser<{className}>"); 
        sourceBuilder.AppendLine("    {");
        
        // Generate static parser
        sourceBuilder.AppendLine($"        private static readonly MessageParser<{className}> _parser = new MessageParser<{className}>(() => new {className}());");
        sourceBuilder.AppendLine($"        public static MessageParser<{className}> Parser {{ get {{ return _parser; }} }}");
        sourceBuilder.AppendLine();
        
        // Add descriptor (simplified)
        sourceBuilder.AppendLine("        public static MessageDescriptor Descriptor => throw new NotImplementedException(\"Descriptor not yet implemented\");");
        sourceBuilder.AppendLine("        MessageDescriptor IMessage.Descriptor => Descriptor;");
        sourceBuilder.AppendLine();
        
        // Add unknown fields
        sourceBuilder.AppendLine("        private UnknownFieldSet _unknownFields;");
        sourceBuilder.AppendLine();
        
        // Generate Clone method
        sourceBuilder.AppendLine($"        public {className} Clone()");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine($"            return new {className}(this);");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        // Generate copy constructor (minimal)
        sourceBuilder.AppendLine($"        public {className}({className} other)");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            if (other == null) return;");
        sourceBuilder.AppendLine("            // TODO: Copy properties");
        sourceBuilder.AppendLine("            _unknownFields = UnknownFieldSet.Clone(other._unknownFields);");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        // Generate Equals methods
        sourceBuilder.AppendLine("        public override bool Equals(object other)");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine($"            return Equals(other as {className});");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        sourceBuilder.AppendLine($"        public bool Equals({className} other)");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            if (ReferenceEquals(other, null)) return false;");
        sourceBuilder.AppendLine("            if (ReferenceEquals(other, this)) return true;");
        sourceBuilder.AppendLine("            // TODO: Compare properties");
        sourceBuilder.AppendLine("            return Equals(_unknownFields, other._unknownFields);");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        // Generate GetHashCode
        sourceBuilder.AppendLine("        public override int GetHashCode()");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            int hash = 1;");
        sourceBuilder.AppendLine("            // TODO: Hash properties");
        sourceBuilder.AppendLine("            if (_unknownFields != null) hash ^= _unknownFields.GetHashCode();");
        sourceBuilder.AppendLine("            return hash;");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        // Generate ToString
        sourceBuilder.AppendLine("        public override string ToString()");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine($"            return $\"{className} [TODO: implement proper ToString]\";");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        // Generate basic serialization methods - simplified for now
        sourceBuilder.AppendLine("        public void WriteTo(CodedOutputStream output)");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            // TODO: Write properties");
        sourceBuilder.AppendLine("            if (_unknownFields != null)");
        sourceBuilder.AppendLine("                _unknownFields.WriteTo(output);");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        sourceBuilder.AppendLine("        public int CalculateSize()");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            int size = 0;");
        sourceBuilder.AppendLine("            // TODO: Calculate property sizes");
        sourceBuilder.AppendLine("            if (_unknownFields != null)");
        sourceBuilder.AppendLine("                size += _unknownFields.CalculateSize();");
        sourceBuilder.AppendLine("            return size;");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        sourceBuilder.AppendLine($"        public void MergeFrom({className} other)");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            if (other == null) return;");
        sourceBuilder.AppendLine("            // TODO: Merge properties");
        sourceBuilder.AppendLine("            _unknownFields = UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
        
        sourceBuilder.AppendLine("        public void MergeFrom(CodedInputStream input)");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            uint tag;");
        sourceBuilder.AppendLine("            while ((tag = input.ReadTag()) != 0)");
        sourceBuilder.AppendLine("            {");
        sourceBuilder.AppendLine("                // TODO: Parse properties from input");
        sourceBuilder.AppendLine("                _unknownFields = UnknownFieldSet.MergeFieldFrom(_unknownFields, input);");
        sourceBuilder.AppendLine("            }");
        sourceBuilder.AppendLine("        }");
        
        sourceBuilder.AppendLine("    }");
        sourceBuilder.AppendLine("}");
        
        return sourceBuilder.ToString();
    }
}