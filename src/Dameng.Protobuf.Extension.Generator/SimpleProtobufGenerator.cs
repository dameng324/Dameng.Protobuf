using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Dameng.Protobuf.Extension.Generator;

[Generator]
public class SimpleProtobufGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
    }

    public void Execute(GeneratorExecutionContext context)
    {
        var processedTypes = new HashSet<string>();

        foreach (var syntaxTree in context.Compilation.SyntaxTrees)
        {
            var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);

            foreach (var node in syntaxTree.GetRoot().DescendantNodesAndSelf())
            {
                INamedTypeSymbol? targetType;

                // Support class, record, record struct, and struct declarations
                if (node is ClassDeclarationSyntax classDeclaration)
                {
                    targetType =
                        semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
                }
                else if (node is StructDeclarationSyntax structDeclaration)
                {
                    targetType =
                        semanticModel.GetDeclaredSymbol(structDeclaration) as INamedTypeSymbol;
                }
                else
                {
                    // Handle records using reflection for compatibility
                    var nodeTypeName = node.GetType().Name;
                    if (nodeTypeName.Contains("RecordDeclaration"))
                    {
                        var symbolInfo = semanticModel.GetDeclaredSymbol(node);
                        targetType = symbolInfo as INamedTypeSymbol;
                    }
                    else
                    {
                        continue;
                    }
                }

                if (targetType is null)
                    continue;

                // Prevent duplicate processing
                var typeKey =
                    $"{targetType.ToDisplayString()}@{targetType.Locations.FirstOrDefault()?.SourceTree?.FilePath}";
                if (!processedTypes.Add(typeKey))
                    continue;

                // Look for ProtoContract attribute
                var hasProtoContract = false;
                foreach (var attr in targetType.GetAttributes())
                {
                    if (
                        attr.AttributeClass?.ToDisplayString()
                        == "Dameng.Protobuf.Extension.ProtoContractAttribute"
                    )
                    {
                        hasProtoContract = true;
                        break;
                    }
                }

                if (!hasProtoContract)
                    continue;

                // Generate the basic IMessage implementation
                var sourceCode = GenerateBasicProtobufMessage(context.Compilation, targetType);
                var fileName = $"{targetType.ToDisplayString()}.g.cs";
                context.AddSource(fileName, SourceText.From(sourceCode, Encoding.UTF8));
            }
        }
    }

    private string GenerateBasicProtobufMessage(
        Compilation compilation,
        INamedTypeSymbol targetType
    )
    {
        var namespaceName = targetType.ContainingNamespace.ToDisplayString();
        var className = targetType.Name;

        var typeDeclarationString = targetType.IsValueType
            ? targetType.IsRecord
                ? "partial record struct"
                : "partial struct"
            : targetType.IsRecord
                ? "partial record"
                : "partial class";

        var sourceBuilder = new StringBuilder();

        sourceBuilder.AppendLine(
            $$"""
              // <auto-generated>
              //     Generated by {{nameof(
                  SimpleProtobufGenerator
              )}} at {{DateTime.Now:yyyy-MM-dd HH:mm:ss}}
              // </auto-generated>

              #pragma warning disable 1591, 0612, 3021, 8981, CS9035
              using System;
              using System.Linq;
              using Dameng.Protobuf.Extension;
              using Google.Protobuf.WellKnownTypes;
              using pb = global::Google.Protobuf;
              namespace {{namespaceName}};
              [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
              {{(
                  targetType.IsValueType
                      ? "[global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Auto)]"
                      : ""
              )}}
              {{typeDeclarationString}} {{className}} : IProtoBufMessage<{{className}}>
              """
        );

        var protoMembers = GetProtoMembers(targetType);

        sourceBuilder.AppendLine(
            $$"""
              {
                  public void WriteTo(ref pb::WriteContext output)
                  {
                      {{string.Join(Environment.NewLine + GetIntendedSpace(2),
                          GetProtoMembers(targetType).Select(member => {
                              string proxyType = "";
                              if (member.ProxyType is not null)
                              {
                                  proxyType = $"({member.ProxyType})";
                              }

                              if (IsCollectionType(member.Type))
                              {
                                  var elementType = GetElementType(member.Type);
                                  var count = GetCollectionCountPropertyName(member.Type);
                                  return $"if({member.Name}?.{count}>0) WriteContextInternal.WriteRepeated<{member.Type},{elementType}>(ref output, {proxyType}({member.Name}),DataFormat.{member.DataFormat}, {member.RawTag},static c=>c.{count},static c=>c.GetEnumerator());";
                              }

                              if (IsProtoBufMessage(member.Type))
                              {
                                  return $"if({member.Name}!=null){{ output.WriteTag({member.RawTag}); output.WriteLength({member.Name}.CalculateSize()); {member.Name}.WriteTo(ref output); }}";
                              }

                              return $"if(Check.IsEmpty({member.Name})==false) WriteContextInternal.Write(ref output, {proxyType}({member.Name}),DataFormat.{member.DataFormat}, {member.RawTag});";
                          }))
                      }}
                  }
                  
                  public int CalculateSize() {
                      int size=0;
                      {{string.Join(Environment.NewLine + GetIntendedSpace(2),
                          GetProtoMembers(targetType).Select(member => {
                              var tagSize = member.RawTagBytes.Length;
                              string proxyType = "";
                              if (member.ProxyType is not null)
                              {
                                  proxyType = $"({member.ProxyType})";
                              }

                              if (IsCollectionType(member.Type))
                              {
                                  var elementType = GetElementType(member.Type);
                                  var count = GetCollectionCountPropertyName(member.Type);
                                  return $"if({member.Name}?.{count}>0) size+=SizeCalculator.CalculateRepeated<{member.Type},{elementType}>({proxyType}({member.Name}),DataFormat.{member.DataFormat},{member.RawTag},static c=>c.{count},static c=>c.GetEnumerator());";
                              }

                              if (IsProtoBufMessage(member.Type))
                              {
                                  return $"if({member.Name}!=null){{ var messageSize ={member.Name}.CalculateSize(); size+={tagSize}+messageSize+ pb::CodedOutputStream.ComputeLengthSize(messageSize); }} ";
                              }

                              return $"if(Check.IsEmpty({member.Name})==false) size+=SizeCalculator.Calculate({proxyType}({member.Name}),DataFormat.{member.DataFormat},{tagSize});";
                          }))
                      }}
                      return size;
                  }
                  
                  public static {{className}} ParseFrom(ref pb::ParseContext input)
                  {
                      {{string.Join(Environment.NewLine + GetIntendedSpace(2),
                          GetProtoMembers(targetType).Select(member => {
                              return $"{(member.ProxyType ?? member.Type).ToDisplayString()} _{member.Name} = default;";
                          }))
                      }}
                      uint tag;
                      while ((tag = input.ReadTag()) != 0) 
                      {
                          if ((tag & 7) == 4) {
                            break;
                          }
                          switch(tag) 
                          {
                              default:
                              break;
                              {{string.Join(Environment.NewLine + GetIntendedSpace(4), GetProtoMembers(targetType).Select(member =>
                                  {
                                      var caseStatement = $"case {member.RawTag}:";
                                      if (IsCollectionType(member.Type))
                                      {
                                          var elementType = GetElementType(member.Type);
                                          var tag2 = ProtoMember.GetRawTag(member.Tag, ProtoMember.GetPbWireType(elementType, member.DataFormat));
                                          if (tag2 != member.RawTag)
                                          {
                                              caseStatement += $" case {tag2}:";
                                          }

                                          var addMethod = "Add";
                                          if (IsStackType(member.Type))
                                              addMethod = "Push";
                                          if (IsQueueType(member.Type))
                                              addMethod = "Enqueue";
                                          return $"{caseStatement} {{_{member.Name} = ParseContextInternal.ReadRepeated<{(member.ProxyType ?? member.Type).ToDisplayString()},{elementType.ToDisplayString()}>(ref input,DataFormat.{member.DataFormat},static capacity=>{NewConcreteTypeCollectionWithCapacity(compilation, member.Type, "capacity")},static (c,i)=>c.{addMethod}(i)); break;}}";
                                      }

                                      var memberType = member.ProxyType ?? member.Type;
                                      if (IsProtoBufMessage(memberType))
                                      {
                                          return $"{caseStatement} {{_{member.Name} = {(memberType).ToDisplayString()}.ParseFrom(ref input); break;}}";
                                      }
                                      return $"{caseStatement} {{_{member.Name} = ParseContextInternal.Read<{memberType.ToDisplayString()}>(ref input,DataFormat.{member.DataFormat}); break;}}";
                                  }))
                              }}
                          }
                      }
                      
                      return new {{className}}()
                      {
                          {{string.Join(Environment.NewLine + GetIntendedSpace(3),
                              GetProtoMembers(targetType).Select(member => $"{member.Name} = _{member.Name},"))
                          }}
                      };
                  }
              }
              """
        );
        return sourceBuilder.ToString();
    }

    private bool IsProtoBufMessage(ITypeSymbol memberType)
    {
        return memberType.TypeKind!= TypeKind.Enum && memberType.GetAttributes().Any(o=>o.AttributeClass?.ToDisplayString()=="Dameng.Protobuf.Extension.ProtoContractAttribute")
               || (memberType is INamedTypeSymbol namedType
                   && namedType.AllInterfaces.Any(i => i.ToDisplayString().StartsWith("Dameng.Protobuf.Extension.IProtoBufMessage<")));
    }

    static string NewConcreteTypeCollectionWithCapacity(
        Compilation compilation,
        ITypeSymbol type,
        string capacity
    )
    {
        if (type is not INamedTypeSymbol namedType)
            return $"new {GetConcreteTypeName(compilation, type)}()";

        var concreteType = ResolveConcreteTypeSymbol(compilation, namedType);
        if (SupportsCapacityConstructor(concreteType))
        {
            return $"new {concreteType}({capacity})";
        }
        else
        {
            return $"new {concreteType}()";
        }
    }

    static bool SupportsCapacityConstructor(INamedTypeSymbol? typeSymbol)
    {
        if (typeSymbol is null)
        {
            return false;
        }

        return typeSymbol.Constructors.Any(c =>
            !c.IsStatic
            && c.Parameters.Length == 1
            && c.Parameters[0].Type.SpecialType == SpecialType.System_Int32
        );
    }

    static string GetCollectionCountPropertyName(ITypeSymbol type)
    {
        if (IsArrayType(type))
            return "Length";
        return "Count";
    }

    static string GetConcreteTypeName(Compilation compilation, ITypeSymbol type)
    {
        if (type is not INamedTypeSymbol namedType)
            return type.ToDisplayString();

        return ResolveConcreteTypeSymbol(compilation, namedType).ToDisplayString();
    }

    static bool IsArrayType(ITypeSymbol type)
    {
        return type.TypeKind == TypeKind.Array;
    }

    static bool IsListType(ITypeSymbol type)
    {
        if (type is not INamedTypeSymbol namedType)
            return false;

        var typeName = namedType.OriginalDefinition.ToDisplayString();
        return typeName == "System.Collections.Generic.List<T>"
               || typeName == "Google.Protobuf.Collections.RepeatedField<T>"
               || typeName == "System.Collections.Concurrent.ConcurrentBag<T>"
               || typeName == "System.Collections.Immutable.ImmutableArray<T>"
               || typeName == "System.Collections.Immutable.ImmutableList<T>"
               || typeName == "System.Collections.Generic.IList<T>"
               || typeName == "System.Collections.Generic.ICollection<T>"
               || typeName == "System.Collections.Generic.IEnumerable<T>";
    }

    static bool IsSetType(ITypeSymbol type)
    {
        if (type is not INamedTypeSymbol namedType)
            return false;

        var typeName = namedType.OriginalDefinition.ToDisplayString();
        return typeName == "System.Collections.Generic.HashSet<T>"
               || typeName == "System.Collections.Immutable.ImmutableHashSet<T>"
               || typeName == "System.Collections.Generic.ISet<T>";
    }

    static bool IsQueueType(ITypeSymbol type)
    {
        if (type is not INamedTypeSymbol namedType)
            return false;
        var typeName = namedType.OriginalDefinition.ToDisplayString();
        return typeName == "System.Collections.Generic.Queue<T>"
               || typeName == "System.Collections.Immutable.ImmutableQueue<T>"
               || typeName == "System.Collections.Concurrent.ConcurrentQueue<T>";
    }

    static ITypeSymbol GetElementType(ITypeSymbol collectionType)
    {
        if (IsArrayType(collectionType))
        {
            return ((IArrayTypeSymbol)collectionType).ElementType;
        }

        if (
            (
                IsListType(collectionType)
                || IsSetType(collectionType)
                || IsStackType(collectionType)
                || IsQueueType(collectionType)
            ) && collectionType is INamedTypeSymbol namedType
        )
        {
            return namedType.TypeArguments[0];
        }

        throw new ArgumentException(
            "Type is not an array, list, set, or concurrent collection type",
            nameof(collectionType)
        );
    }

    static bool IsStackType(ITypeSymbol type)
    {
        if (type is not INamedTypeSymbol namedType)
            return false;
        var typeName = namedType.OriginalDefinition.ToDisplayString();
        return typeName == "System.Collections.Generic.Stack<T>"
               || typeName == "System.Collections.Immutable.ImmutableStack<T>"
               || typeName == "System.Collections.Concurrent.ConcurrentStack<T>";
    }

    static bool IsCollectionType(ITypeSymbol type)
    {
        return IsArrayType(type)
               || IsListType(type)
               || IsSetType(type)
               || IsQueueType(type)
               || IsStackType(type);
    }

    static bool IsDictionaryType(ITypeSymbol type)
    {
        if (type is not INamedTypeSymbol namedType)
            return false;

        var typeName = namedType.OriginalDefinition.ToDisplayString();
        // Dictionary uses different template parameter names based on actual Roslyn behavior
        return typeName == "System.Collections.Generic.Dictionary<TKey, TValue>"
               || typeName == "System.Collections.Generic.IDictionary<TKey, TValue>"
               || typeName == "System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>"
               || typeName == "System.Collections.Immutable.ImmutableDictionary<TKey, TValue>"
               || typeName == "System.Collections.Concurrent.ConcurrentDictionary<TKey, TValue>";
    }

    static INamedTypeSymbol ResolveConcreteTypeSymbol(
        Compilation compilation,
        INamedTypeSymbol type
    )
    {
        // 如果是接口，就手动映射到具体类型
        var constructedFrom = type.OriginalDefinition.ToDisplayString();

        return constructedFrom switch
        {
            "System.Collections.Generic.IList<T>"
                or "System.Collections.Generic.IEnumerable<T>"
                or "System.Collections.Generic.ICollection<T>"
                or "System.Collections.Generic.IReadOnlyCollection<T>" => compilation
                    .GetTypeByMetadataName("System.Collections.Generic.List`1")
                    ?.Construct(type.TypeArguments.ToArray()) ?? type,

            "System.Collections.Generic.IDictionary<TKey, TValue>"
                or "System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>" => compilation
                    .GetTypeByMetadataName("System.Collections.Generic.Dictionary`2")
                    ?.Construct(type.TypeArguments.ToArray()) ?? type,

            "System.Collections.Generic.ISet<T>" => compilation
                .GetTypeByMetadataName("System.Collections.Generic.HashSet`1")
                ?.Construct(type.TypeArguments.ToArray()) ?? type,

            _ => type, // 如果本身就是具体类，就直接返回
        };
    }

    string GetIntendedSpace(int i)
    {
        return new string(' ', i * 4);
    }

    static bool IsGuidType(ITypeSymbol type)
    {
        var displayString = type.ToDisplayString();
        return displayString == "System.Guid" || displayString == "Guid";
    }

    static bool IsTimeSpanType(ITypeSymbol type)
    {
        var displayString = type.ToDisplayString();
        return displayString == "System.TimeSpan" || displayString == "TimeSpan";
    }

    static bool IsDateOnlyType(ITypeSymbol type)
    {
        var displayString = type.ToDisplayString();
        return displayString == "System.DateOnly" || displayString == "DateOnly";
    }

    static bool IsTimeOnlyType(ITypeSymbol type)
    {
        var displayString = type.ToDisplayString();
        return displayString == "System.TimeOnly" || displayString == "TimeOnly";
    }

    static bool IsStringBuilderType(ITypeSymbol type)
    {
        var displayString = type.ToDisplayString();
        return displayString == "System.Text.StringBuilder" || displayString == "StringBuilder";
    }

    private ITypeSymbol? GetProxyType(IEnumerable<AttributeData> attributeDatas)
    {
        if (
            attributeDatas.FirstOrDefault(o =>
                o.AttributeClass?.ToDisplayString()
                    .StartsWith("Dameng.Protobuf.Extension.ProtoProxyAttribute<") == true
            ) is
            { } proxyAttr2
        )
        {
            return proxyAttr2.AttributeClass!.TypeArguments[0];
        }

        return null;
    }

    private ITypeSymbol? GetProxyType(ITypeSymbol type)
    {
        return GetProxyType(type.GetAttributes());
    }

    private List<ProtoMember> GetProtoMembers(INamedTypeSymbol targetType)
    {
        var members = new List<ProtoMember>();

        foreach (var member in targetType.GetMembers())
        {
            if (!(member is IPropertySymbol property) || property.IsStatic)
                continue;

            AttributeData? protoMemberAttr = null;
            foreach (var attr in property.GetAttributes())
            {
                if (
                    attr.AttributeClass?.ToDisplayString()
                    == "Dameng.Protobuf.Extension.ProtoMemberAttribute"
                )
                {
                    protoMemberAttr = attr;
                    break;
                }
            }

            if (protoMemberAttr == null)
                continue;
            ITypeSymbol? proxyType = GetProxyType(property.GetAttributes());
            if (proxyType is null)
            {
                proxyType = GetProxyType(property.Type);
            }

            var tag = (uint)protoMemberAttr.ConstructorArguments[0].Value!;
            members.Add(
                new ProtoMember
                {
                    Name = property.Name,
                    Type = property.Type,
                    Tag = tag,
                    IsRequired = property.IsRequired,
                    IsInitOnly = property.SetMethod?.IsInitOnly == true,
                    AttributeData = property.GetAttributes(),
                    DataFormat = Enum.TryParse<DataFormat>(
                        protoMemberAttr
                            .NamedArguments.FirstOrDefault(kv => kv.Key == "DataFormat")
                            .Value.Value?.ToString(),
                        out var value
                    )
                        ? value
                        : DataFormat.Default,
                    ProxyType = proxyType,
                }
            );
        }

        return members.OrderBy(m => m.Tag).ToList();
    }

    private class ProtoMember
    {
        public enum PbWireType
        {
            Varint = 0, // int32, int64, bool, enum ,uint32, uint64
            Fixed64 = 1, // double, fixed64, sfixed64
            LengthDelimited = 2, // string, bytes, message, repeated packed
            Fixed32 = 5, // float, fixed32, sfixed32
        }

        public ITypeSymbol? ProxyType { get; set; }
        public string Name { get; set; } = "";
        public ITypeSymbol Type { get; set; } = null!;
        public DataFormat DataFormat { get; set; }
        public uint Tag { get; set; }
        public bool IsRequired { get; set; }
        public bool IsInitOnly { get; set; }

        public ImmutableArray<AttributeData> AttributeData { get; set; } =
            ImmutableArray<AttributeData>.Empty;

        public PbWireType WireType => GetPbWireType(Type, DataFormat);

        public static PbWireType GetPbWireType(ITypeSymbol Type, DataFormat DataFormat)
        {
            // Handle nullable value types by getting the underlying type
            if (
                Type is INamedTypeSymbol namedType
                && namedType.OriginalDefinition?.SpecialType == SpecialType.System_Nullable_T
            )
            {
                return GetPbWireType(namedType.TypeArguments[0], DataFormat);
            }

            // Handle arrays, lists and sets
            if (IsCollectionType(Type))
            {
                return PbWireType.LengthDelimited;
            }

            // Handle dictionaries
            if (IsDictionaryType(Type))
            {
                return PbWireType.LengthDelimited;
            }

            if (Type.TypeKind == TypeKind.Enum)
            {
                return PbWireType.Varint;
            }

            switch (Type.SpecialType)
            {
                case SpecialType.System_Boolean:
                case SpecialType.System_Int32:
                {
                    return DataFormat == DataFormat.FixedSize
                        ? PbWireType.Fixed32
                        : PbWireType.Varint;
                }
                case SpecialType.System_UInt32:
                {
                    return DataFormat == DataFormat.FixedSize
                        ? PbWireType.Fixed32
                        : PbWireType.Varint;
                }
                case SpecialType.System_Int64:
                {
                    return DataFormat == DataFormat.FixedSize
                        ? PbWireType.Fixed64
                        : PbWireType.Varint;
                }
                case SpecialType.System_UInt64:
                {
                    return DataFormat == DataFormat.FixedSize
                        ? PbWireType.Fixed64
                        : PbWireType.Varint;
                }
                case SpecialType.System_Enum:
                    return PbWireType.Varint;
                case SpecialType.System_Single:
                    return PbWireType.Fixed32;
                case SpecialType.System_Double:
                    return PbWireType.Fixed64;
                case SpecialType.System_String:
                case SpecialType.System_DateTime:
                case SpecialType.None when Type.ToDisplayString() == "Google.Protobuf.ByteString":
                case SpecialType.None when IsGuidType(Type):
                case SpecialType.None when IsTimeSpanType(Type):
                case SpecialType.None when IsDateOnlyType(Type):
                case SpecialType.None when IsTimeOnlyType(Type):
                case SpecialType.None when IsStringBuilderType(Type):
                case SpecialType.None
                    when Type.TypeKind == TypeKind.Class
                         || Type.TypeKind == TypeKind.Interface
                         || Type.TypeKind == TypeKind.Array:
                    return PbWireType.LengthDelimited;
                default:
                    if (
                        Type.ToDisplayString()
                        .StartsWith("Google.Protobuf.Collections.RepeatedField")
                    )
                    {
                        // For simplicity, assume packed repeated fields use LengthDelimited
                        return PbWireType.LengthDelimited;
                    }

                    // Default to LengthDelimited for other complex types
                    return PbWireType.LengthDelimited;
            }
        }

        public uint RawTag => GetRawTag(Tag, WireType);
        public byte[] RawTagBytes => GetRawBytes(Tag, WireType);

        public static uint GetRawTag(uint Tag, PbWireType WireType)
        {
            return (Tag << 3) | (uint)WireType;
        }

        public static byte[] GetRawBytes(uint fieldNumber, PbWireType wireType)
        {
            uint tag = (fieldNumber << 3) | (uint)wireType;
            return EncodeVarint(tag);
        }

        private static byte[] EncodeVarint(uint value)
        {
            var bytes = new List<byte>();
            while (value > 127)
            {
                bytes.Add((byte)((value & 0x7F) | 0x80)); // 低7位 + 最高位1，表示后面还有字节
                value >>= 7;
            }

            bytes.Add((byte)value); // 最后一个字节
            return bytes.ToArray();
        }
    }
}