using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using CSharpExtensions = Microsoft.CodeAnalysis.CSharp.CSharpExtensions;

namespace Dameng.Protobuf.Extension.Generator;

[Generator]
public class SimpleProtobufGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context) { }

    public void Execute(GeneratorExecutionContext context)
    {
        var processedTypes = new HashSet<string>();

        foreach (var syntaxTree in context.Compilation.SyntaxTrees)
        {
            var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);

            foreach (var node in syntaxTree.GetRoot().DescendantNodesAndSelf())
            {
                INamedTypeSymbol? targetType;

                // Support class, record, record struct, and struct declarations
                if (node is ClassDeclarationSyntax classDeclaration)
                {
                    targetType =
                        ModelExtensions.GetDeclaredSymbol(semanticModel, classDeclaration)
                        as INamedTypeSymbol;
                }
                else if (node is StructDeclarationSyntax structDeclaration)
                {
                    targetType =
                        ModelExtensions.GetDeclaredSymbol(semanticModel, structDeclaration)
                        as INamedTypeSymbol;
                }
                else
                {
                    // Handle records using reflection for compatibility
                    var nodeTypeName = node.GetType().Name;
                    if (nodeTypeName.Contains("RecordDeclaration"))
                    {
                        var symbolInfo = semanticModel.GetDeclaredSymbol(node);
                        targetType = symbolInfo as INamedTypeSymbol;
                    }
                    else
                    {
                        continue;
                    }
                }

                if (targetType is null)
                    continue;

                // Prevent duplicate processing
                var typeKey =
                    $"{targetType}@{targetType.Locations.FirstOrDefault()?.SourceTree?.FilePath}";
                if (!processedTypes.Add(typeKey))
                    continue;

                // Look for ProtoContract attribute
                var hasProtoContract = false;
                foreach (var attr in targetType.GetAttributes())
                {
                    if (
                        attr.AttributeClass?.ToDisplayString()
                        == "Dameng.Protobuf.Extension.ProtoContractAttribute"
                    )
                    {
                        hasProtoContract = true;
                        break;
                    }
                }

                if (!hasProtoContract)
                    continue;

                // Generate the basic IMessage implementation
                var sourceCode = GenerateBasicProtobufMessage(context.Compilation, targetType);
                var fileName = $"{targetType}.g.cs";
                context.AddSource(fileName, SourceText.From(sourceCode, Encoding.UTF8));
            }
        }
    }

    private string GenerateBasicProtobufMessage(
        Compilation compilation,
        INamedTypeSymbol targetType
    )
    {
        var namespaceName = targetType.ContainingNamespace.ToDisplayString();
        var className = targetType.Name;

        var typeDeclarationString = targetType.IsValueType
            ? targetType.IsRecord
                ? "partial record struct"
                : "partial struct"
            : targetType.IsRecord
                ? "partial record"
                : "partial class";

        var sourceBuilder = new StringBuilder();

        sourceBuilder.AppendLine(
            $$"""
              // <auto-generated>
              //     Generated by {{nameof(
                  SimpleProtobufGenerator
              )}} at {{DateTime.Now:yyyy-MM-dd HH:mm:ss}}
              // </auto-generated>

              #pragma warning disable 1591, 0612, 3021, 8981, CS9035
              using System;
              using System.Linq;
              using Dameng.Protobuf.Extension;
              using Google.Protobuf.WellKnownTypes;
              using pb = global::Google.Protobuf;
              namespace {{namespaceName}};
              [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
              {{(
                  targetType.IsValueType
                      ? "[global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Auto)]"
                      : ""
              )}}
              {{typeDeclarationString}} {{className}} : IProtoMessage<{{className}}>
              """
        );

        var protoMembers = GetProtoMembers(compilation, targetType);

        sourceBuilder.AppendLine(
            $$"""
              {
                  public static IProtoReader<{{className}}> Reader {get; } = new ProtoReader();
                  public static IProtoWriter<{{className}}> Writer {get; } = new ProtoWriter();
                  public sealed class ProtoWriter:IProtoMessageWriter<{{className}}>
                  {
                      {{string.Join(Environment.NewLine + GetIntendedSpace(2),
                          protoMembers.SelectMany(member => GetProtoParserMember(compilation, member, "Writer", targetType)))
                      }}
                      public void WriteTo(ref pb::WriteContext output, {{className}} value)
                      {
                          {{string.Join(Environment.NewLine + GetIntendedSpace(3),
                              protoMembers.SelectMany(member => {
                                  return Gen();

                                  IEnumerable<string> Gen()
                                  {
                                      var checkIfNotEmpty = GetCheckIfNotEmpty(member);

                                      if (IsCollectionType(compilation, member.Type) || IsDictionaryType(compilation, member.Type))
                                      {
                                          yield return $"if({checkIfNotEmpty})";
                                          yield return $"{{";
                                          yield return $"    {member.Name}_ProtoWriter.WriteTo(ref output, value.{member.Name});";
                                          yield return $"}} ";
                                      }
                                      else
                                      {
                                          yield return $"if({checkIfNotEmpty})";
                                          yield return $"{{";
                                          yield return $"    output.WriteTag({member.RawTag}); ";
                                          yield return $"    if({member.Name}_ProtoWriter is IProtoMessageWriter<{member.Type}> messageWriter) ";
                                          yield return $"         messageWriter.WriteMessageTo(ref output, value.{member.Name});";
                                          yield return $"    else";
                                          yield return $"         {member.Name}_ProtoWriter.WriteTo(ref output, value.{member.Name});";
                                          yield return $"}}";
                                      }
                                  }
                              }))
                          }}
                      }
                      
                      public int CalculateSize({{className}} value) {
                          int size=0;
                          {{string.Join(Environment.NewLine + GetIntendedSpace(3),
                              protoMembers.SelectMany(member => {
                                  return Gen();

                                  IEnumerable<string> Gen()
                                  {
                                      var tagSize = member.RawTagBytes.Length;
                                      var checkIfNotEmpty = GetCheckIfNotEmpty(member);

                                      if (IsCollectionType(compilation, member.Type) || IsDictionaryType(compilation, member.Type))
                                      {
                                          yield return $"if(value.{member.Name}!=null)";
                                          yield return $"    size += {member.Name}_ProtoWriter.CalculateSize(value.{member.Name}); ";
                                      }
                                      else
                                      {
                                          yield return $"if({checkIfNotEmpty})";
                                          yield return $"    if({member.Name}_ProtoWriter is IProtoMessageWriter<{member.Type}> messageWriter) ";
                                          yield return $"        size += {tagSize} + messageWriter.CalculateMessageSize(value.{member.Name});";
                                          yield return $"    else";
                                          yield return $"        size += {tagSize} + {member.Name}_ProtoWriter.CalculateSize(value.{member.Name});";
                                      }
                                  }
                              }))
                          }}
                          return size;
                      }
                  }
                  
                  public sealed class ProtoReader:IProtoMessageReader<{{className}}>
                  {
                      {{string.Join(Environment.NewLine + GetIntendedSpace(2),
                          protoMembers.SelectMany(member => GetProtoParserMember(compilation, member, "Reader", targetType)))
                      }}
                      public {{className}} ParseFrom(ref pb::ParseContext input)
                      {
                          {{string.Join(Environment.NewLine + GetIntendedSpace(3),
                              protoMembers.Select(member => $"{member.Type} _{member.Name} = default;"))
                          }}
                          uint tag;
                          while ((tag = input.ReadTag()) != 0) 
                          {
                              if ((tag & 7) == 4) {
                                break;
                              }
                              switch(tag) 
                              {
                                  default:
                                  break;
                                  {{string.Join(Environment.NewLine + GetIntendedSpace(5), protoMembers.SelectMany(member =>
                                      {
                                          return Gen();

                                          IEnumerable<string> Gen()
                                          {
                                              yield return $"case {member.RawTag}:";
                                              if (IsCollectionType(compilation, member.Type))
                                              {
                                                  var elementType = GetElementType(compilation, member.Type);
                                                  var tag2 = ProtoMember.GetRawTag(member.Tag, ProtoMember.GetPbWireType(compilation, elementType, member.DataFormat));
                                                  if (tag2 != member.RawTag)
                                                  {
                                                      yield return $"case {tag2}:";
                                                  }
                                              }

                                              yield return $"{{";
                                              yield return $"    if({member.Name}_ProtoReader is IProtoMessageReader<{member.Type}> messageReader) ";
                                              yield return $"        _{member.Name} = messageReader.ParseMessageFrom(ref input);";
                                              yield return $"    else";
                                              yield return $"        _{member.Name} = {member.Name}_ProtoReader.ParseFrom(ref input);";
                                              yield return $"    break;";
                                              yield return $"}}";
                                          }
                                      }))
                                  }}
                              }
                          }
                          
                          return new {{className}}()
                          {
                              {{string.Join(Environment.NewLine + GetIntendedSpace(4),
                                  protoMembers.Select(member => $"{member.Name} = _{member.Name},"))
                              }}
                          };
                      }
                  }
              }
              """
        );
        return sourceBuilder.ToString();
    }

    private string GetCheckIfNotEmpty(ProtoMember member)
    {
        if (member.Type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T)
        {
            return $"value.{member.Name}.HasValue && value.{member.Name}.Value != default";
        }

        if (member.Type.IsValueType)
        {
            return $"value.{member.Name} != default";
        }

        var check = $"value.{member.Name} != null";

        if (HasCountProperty(member.Type))
        {
            return $"{check} && value.{member.Name}.Count > 0";
        }
        if (HasLengthProperty(member.Type))
        {
            return $"{check} && value.{member.Name}.Length > 0";
        }

        return check;
    }

    public static bool HasCountProperty(ITypeSymbol type)
    {
        return HasProperty(type, "Count", SpecialType.System_Int32);
    }

    public static bool HasLengthProperty(ITypeSymbol type)
    {
        return HasProperty(type, "Length", SpecialType.System_Int32);
    }

    public static bool HasProperty(ITypeSymbol type, string name, SpecialType specialType)
    {
        if (
            type.GetMembers()
                .OfType<IPropertySymbol>()
                .Any(o => o.Name == name && o.Type.SpecialType == specialType)
        )
        {
            return true;
        }

        if (type.TypeKind == TypeKind.Interface)
        {
            if (type.AllInterfaces.Any(x => HasProperty(x, name, specialType)))
            {
                return true;
            }
        }
        return false;
    }

    public enum ParserType
    {
        Primitive,
        Message,
        Collection,
        Dictionary,
    }

    private IEnumerable<string> GetProtoParserMember(
        Compilation compilation,
        ProtoMember member,
        string readOrWriter,
        ITypeSymbol targetType
    )
    {
        var protoParser = GetProtoParser(
            compilation,
            member.ProtoWriterType ?? member.Type,
            member.DataFormat,
            member.MapFormat,
            readOrWriter,
            member.RawTag,
            targetType
        );
        yield return $"private IProto{readOrWriter}<{member.Type}> _{member.Name}_Proto{readOrWriter};";
        yield return $"private IProto{readOrWriter}<{member.Type}> {member.Name}_Proto{readOrWriter} {{ get => _{member.Name}_Proto{readOrWriter} ??= {protoParser};}}";
    }

    private string GetProtoParser(
        Compilation compilation,
        ITypeSymbol memberType,
        DataFormat format,
        (DataFormat keyFormat, DataFormat valueFormat) mapFormat,
        string readerOrWriter,
        uint rawTag,
        ITypeSymbol targetType
    )
    {
        if (SymbolEqualityComparer.IncludeNullability.Equals(targetType, memberType))
        {
            return "this";
        }

        if (IsProtoBufMessage(memberType))
        {
            return $"{memberType}.{readerOrWriter}";
        }

        if (memberType is IArrayTypeSymbol arrayType)
        {
            if (rawTag == 0)
            {
                throw new Exception("rawTag==0");
            }

            var elementType = arrayType.ElementType;
            var elementWriter = GetProtoParser(
                compilation,
                elementType,
                format,
                mapFormat,
                readerOrWriter,
                0,
                targetType
            );
            var fixedSize = GetFixedSize(elementType, format);
            return $"new ArrayProto{readerOrWriter}<{elementType}>({elementWriter},{rawTag},{fixedSize})";
        }

        if (memberType is INamedTypeSymbol namedType)
        {
            var typeArguments = namedType.TypeArguments;

            if (typeArguments.Length == 0)
            {
                if (namedType.TypeKind == TypeKind.Enum)
                {
                    return $"Dameng.Protobuf.Extension.EnumProtoParser<{namedType}>.{readerOrWriter}";
                }

                var name = namedType.SpecialType switch
                {
                    SpecialType.System_Int32 when format is DataFormat.ZigZag => "SInt32",
                    SpecialType.System_Int64 when format is DataFormat.ZigZag => "SInt64",
                    SpecialType.System_Int32 when format is DataFormat.FixedSize => "SFixed32",
                    SpecialType.System_Int64 when format is DataFormat.FixedSize => "SFixed64",
                    SpecialType.System_UInt32 when format is DataFormat.FixedSize => "Fixed32",
                    SpecialType.System_UInt64 when format is DataFormat.FixedSize => "Fixed64",
                    _ => namedType.Name,
                };

                return $"Dameng.Protobuf.Extension.{name}ProtoParser.{readerOrWriter}";
            }

            if (typeArguments.Length == 1)
            {
                if (rawTag == 0)
                {
                    throw new Exception("rawTag==0");
                }

                var elementType = typeArguments[0];
                var elementParser = GetProtoParser(
                    compilation,
                    elementType,
                    format,
                    mapFormat,
                    readerOrWriter,
                    0,
                    targetType
                );
                var fixedSize = GetFixedSize(elementType, format);
                if (namedType.TypeKind == TypeKind.Interface)
                {
                    if (readerOrWriter == "Reader")
                    {
                        if (IsListType(compilation, namedType))
                        {
                            return $"new ListProto{readerOrWriter}<{elementType}>({elementParser},{rawTag},{fixedSize})";
                        }

                        if (IsSetType(compilation, namedType))
                        {
                            return $"new HashSetProto{readerOrWriter}<{elementType}>({elementParser},{rawTag},{fixedSize})";
                        }
                    }
                    else if (readerOrWriter == "Writer")
                    {
                        if (IsCollectionType(compilation, elementType, namedType))
                        {
                            var count = "Count()";
                            if (HasCountProperty(memberType))
                            {
                                count = "Count";
                            }
                            if (HasLengthProperty(memberType))
                            {
                                count = "Length";
                            }
                            return $"new IEnumerableProto{readerOrWriter}<{memberType},{elementType}>({elementParser},{rawTag},static (d)=>d.{count},{fixedSize})";
                        }
                    }
                }

                if (namedType.TypeKind == TypeKind.Class || namedType.TypeKind == TypeKind.Struct)
                {
                    return $"new {memberType.Name}Proto{readerOrWriter}<{elementType}>({elementParser},{rawTag},{fixedSize})";
                }
            }

            if (typeArguments.Length == 2)
            {
                if (rawTag == 0)
                {
                    throw new Exception("rawTag==0");
                }

                var keyType = typeArguments[0];
                var keyTag = ProtoMember.GetRawTag(
                    1,
                    ProtoMember.GetPbWireType(compilation, keyType, mapFormat.keyFormat)
                );
                var keyWriter = GetProtoParser(
                    compilation,
                    keyType,
                    mapFormat.keyFormat,mapFormat,
                    readerOrWriter,
                    keyTag,
                    targetType
                );
                var valueType = typeArguments[1];
                var valueTag = ProtoMember.GetRawTag(
                    2,
                    ProtoMember.GetPbWireType(compilation, valueType, mapFormat.valueFormat)
                );
                var valueWriter = GetProtoParser(
                    compilation,
                    valueType,
                    mapFormat.valueFormat,
                    mapFormat,
                    readerOrWriter,
                    valueTag,
                    targetType
                );
                if (namedType.TypeKind == TypeKind.Interface)
                {
                    if (readerOrWriter == "Reader")
                    {
                        var mapType = compilation
                            .GetTypeByMetadataName("System.Collections.Generic.Dictionary`2")
                            ?.Construct(keyType, valueType)!;
                        var conversion = CSharpExtensions.ClassifyConversion(
                            compilation,
                            mapType,
                            namedType
                        );
                        if (conversion.IsImplicit)
                        {
                            return $"new DictionaryProto{readerOrWriter}<{keyType},{valueType}>({keyWriter},{valueWriter},{rawTag},{keyTag},{valueTag})";
                        }
                    }
                    else if (readerOrWriter == "Writer")
                    {
                        if (IsDictionaryType(compilation, keyType, valueType, namedType))
                        {
                            var count = "Count()";

                            if (HasCountProperty(memberType))
                            {
                                count = "Count";
                            }
                            return $"new IEnumerableKeyValuePairProto{readerOrWriter}<{memberType},{keyType},{valueType}>({keyWriter},{valueWriter},{rawTag},{keyTag},{valueTag},static (d)=>d.{count})";
                        }
                    }
                }

                if (namedType.TypeKind == TypeKind.Class || namedType.TypeKind == TypeKind.Struct)
                {
                    return $"new {memberType.Name}Proto{readerOrWriter}<{keyType},{valueType}>({keyWriter},{valueWriter},{rawTag},{keyTag},{valueTag})";
                }
            }
        }

        return $"new NotSupported_{memberType.ToDisplayString().Replace('.', '_').Replace('<', '_').Replace('>', '_').Replace('.', '_')}_{readerOrWriter}()";
    }

    private static bool IsCollectionType(Compilation compilation, ITypeSymbol type)
    {
        if (type is IArrayTypeSymbol arrayType)
        {
            return IsCollectionType(compilation, arrayType.ElementType,type);
        }
        
        if (type is not INamedTypeSymbol namedType)
            return false;

        if (namedType.TypeArguments.Length != 1)
            return false;
        var elementType = namedType.TypeArguments[0];

        return IsCollectionType(compilation, elementType, namedType);
    }

    private static bool IsCollectionType(
        Compilation compilation,
        ITypeSymbol elementType,
        ITypeSymbol type
    )
    {
        var baseCollectionType = compilation
            .GetTypeByMetadataName("System.Collections.Generic.IEnumerable`1")
            ?.Construct(elementType)!;
        var conversion = compilation.ClassifyConversion(type, baseCollectionType);
        return conversion.IsImplicit;
    }

    private static bool IsDictionaryType(
        Compilation compilation,
        ITypeSymbol keyType,
        ITypeSymbol valueType,
        INamedTypeSymbol namedType
    )
    {
        var keyValuePairType = compilation
            .GetTypeByMetadataName("System.Collections.Generic.KeyValuePair`2")
            ?.Construct(keyType, valueType)!;
        var baseDictionaryType = compilation
            .GetTypeByMetadataName("System.Collections.Generic.IEnumerable`1")
            ?.Construct(keyValuePairType)!;
        var conversion = compilation.ClassifyConversion(namedType, baseDictionaryType);
        return conversion.IsImplicit;
    }

    static bool IsDictionaryType(Compilation compilation, ITypeSymbol type)
    {
        if (type is not INamedTypeSymbol namedType)
            return false;
        if (namedType.TypeArguments.Length != 2)
            return false;
        var keyType = namedType.TypeArguments[0];
        var valueType = namedType.TypeArguments[1];

        return IsDictionaryType(compilation, keyType, valueType, namedType);
    }

    static ITypeSymbol GetElementType(Compilation compilation, ITypeSymbol collectionType)
    {
        if (IsArrayType(collectionType))
        {
            return ((IArrayTypeSymbol)collectionType).ElementType;
        }

        if (collectionType is INamedTypeSymbol { TypeArguments.Length: 1 } namedType)
        {
            return namedType.TypeArguments[0];
        }

        throw new ArgumentException(
            "Type is not an array, list, set, or concurrent collection type",
            nameof(collectionType)
        );
    }

    private int GetFixedSize(ITypeSymbol elementType, DataFormat dataFormat)
    {
        return elementType.SpecialType switch
        {
            SpecialType.System_Boolean => 1,
            SpecialType.System_Int32
            or SpecialType.System_UInt32 when dataFormat is DataFormat.FixedSize => 4,
            SpecialType.System_Int64
            or SpecialType.System_UInt64 when dataFormat is DataFormat.FixedSize => 8,
            SpecialType.System_Single => 4,
            SpecialType.System_Double => 8,
            _ => 0,
        };
    }

    private bool IsProtoBufMessage(ITypeSymbol memberType)
    {
        return memberType.TypeKind != TypeKind.Enum
                && memberType
                    .GetAttributes()
                    .Any(o =>
                        o.AttributeClass?.ToDisplayString()
                        == "Dameng.Protobuf.Extension.ProtoContractAttribute"
                    )
            || (
                memberType is INamedTypeSymbol namedType
                && namedType.AllInterfaces.Any(i =>
                    i.ToDisplayString().StartsWith("Dameng.Protobuf.Extension.IProtoParser<")
                )
            );
    }

    static bool IsArrayType(ITypeSymbol type)
    {
        return type.TypeKind == TypeKind.Array;
    }

    static bool IsListType(Compilation compilation, ITypeSymbol type)
    {
        if (type is not INamedTypeSymbol namedType)
            return false;

        var typeArguments = namedType.TypeArguments;
        if (typeArguments.Length != 1)
        {
            return false;
        }

        var elementType = typeArguments[0];

        var listType = compilation
            .GetTypeByMetadataName("System.Collections.Generic.List`1")
            ?.Construct(elementType)!;
        var conversion = CSharpExtensions.ClassifyConversion(compilation, listType, type);
        return conversion.IsImplicit;
    }

    static bool IsSetType(Compilation compilation, ITypeSymbol type)
    {
        if (type is not INamedTypeSymbol namedType)
            return false;

        var typeArguments = namedType.TypeArguments;
        if (typeArguments.Length != 1)
        {
            return false;
        }

        var elementType = typeArguments[0];

        var listType = compilation
            .GetTypeByMetadataName("System.Collections.Generic.HashSet`1")
            ?.Construct(elementType)!;
        var conversion = CSharpExtensions.ClassifyConversion(compilation, listType, type);
        return conversion.IsImplicit;
    }

    static INamedTypeSymbol ResolveConcreteTypeSymbol(
        Compilation compilation,
        INamedTypeSymbol type
    )
    {
        // 如果是接口，就手动映射到具体类型
        var constructedFrom = type.OriginalDefinition.ToDisplayString();

        return constructedFrom switch
        {
            "System.Collections.Generic.IList<T>"
            or "System.Collections.Generic.ICollection<T>"
            or "System.Collections.Generic.IReadOnlyCollection<T>" => compilation
                .GetTypeByMetadataName("System.Collections.Generic.List`1")
                ?.Construct(type.TypeArguments.ToArray()) ?? type,

            "System.Collections.Generic.IDictionary<TKey, TValue>"
            or "System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>" => compilation
                .GetTypeByMetadataName("System.Collections.Generic.Dictionary`2")
                ?.Construct(type.TypeArguments.ToArray()) ?? type,

            "System.Collections.Generic.ISet<T>" => compilation
                .GetTypeByMetadataName("System.Collections.Generic.HashSet`1")
                ?.Construct(type.TypeArguments.ToArray()) ?? type,

            _ => type, // 如果本身就是具体类，就直接返回
        };
    }

    string GetIntendedSpace(int i)
    {
        return new string(' ', i * 4);
    }

    static bool IsGuidType(ITypeSymbol type)
    {
        var displayString = type.ToDisplayString();
        return displayString == "System.Guid" || displayString == "Guid";
    }

    static bool IsTimeSpanType(ITypeSymbol type)
    {
        var displayString = type.ToDisplayString();
        return displayString == "System.TimeSpan" || displayString == "TimeSpan";
    }

    static bool IsDateOnlyType(ITypeSymbol type)
    {
        var displayString = type.ToDisplayString();
        return displayString == "System.DateOnly" || displayString == "DateOnly";
    }

    static bool IsTimeOnlyType(ITypeSymbol type)
    {
        var displayString = type.ToDisplayString();
        return displayString == "System.TimeOnly" || displayString == "TimeOnly";
    }

    static bool IsStringBuilderType(ITypeSymbol type)
    {
        var displayString = type.ToDisplayString();
        return displayString == "System.Text.StringBuilder" || displayString == "StringBuilder";
    }

    private (ITypeSymbol? ReaderType, ITypeSymbol? WriterType) GetProxyType(
        IEnumerable<AttributeData> attributeDatas
    )
    {
        if (
            attributeDatas.FirstOrDefault(o =>
                o.AttributeClass?.ToDisplayString()
                    .StartsWith("Dameng.Protobuf.Extension.ProtoParserAttribute<") == true
            ) is
            { } proxyAttr2
        )
        {
            return (
                proxyAttr2.AttributeClass!.TypeArguments[1],
                proxyAttr2.AttributeClass!.TypeArguments[2]
            );
        }

        return (null, null);
    }

    private (ITypeSymbol? ReaderType, ITypeSymbol? WriterType) GetProxyType(ITypeSymbol type)
    {
        return GetProxyType(type.GetAttributes());
    }

    private List<ProtoMember> GetProtoMembers(Compilation compilation, INamedTypeSymbol targetType)
    {
        var members = new List<ProtoMember>();

        foreach (var member in targetType.GetMembers())
        {
            if (!(member is IPropertySymbol property) || property.IsStatic)
                continue;

            AttributeData? protoMemberAttr =  property.GetAttributes().FirstOrDefault(attr => attr.AttributeClass?.ToDisplayString() == "Dameng.Protobuf.Extension.ProtoMemberAttribute");
            if (protoMemberAttr == null)
                continue;
            (ITypeSymbol? ReaderType, ITypeSymbol? WriterType) = GetProxyType(
                property.GetAttributes()
            );
            if (ReaderType is null || WriterType is null)
            {
                (ReaderType, WriterType) = GetProxyType(property.Type);
            }

            var tag = (uint)protoMemberAttr.ConstructorArguments[0].Value!;

            var dataFormat = Enum.TryParse<DataFormat>(
                protoMemberAttr
                    .NamedArguments.FirstOrDefault(kv => kv.Key == "DataFormat")
                    .Value.Value?.ToString(),
                out var _dataFormat
            )
                ? _dataFormat
                : DataFormat.Default;
            AttributeData? protoMapAttr =  property.GetAttributes().FirstOrDefault(attr => attr.AttributeClass?.ToDisplayString() == "Dameng.Protobuf.Extension.ProtoMapAttribute");

            var keyFormat = Enum.TryParse<DataFormat>(
                protoMapAttr?
                    .NamedArguments.FirstOrDefault(kv => kv.Key == "KeyFormat")
                    .Value.Value?.ToString(),
                out var _keyFormat
            )
                ? _keyFormat
                : DataFormat.Default;
            
            var valueFormat = Enum.TryParse<DataFormat>(
                protoMapAttr?
                    .NamedArguments.FirstOrDefault(kv => kv.Key == "ValueFormat")
                    .Value.Value?.ToString(),
                out var _valueFormat
            )
                ? _valueFormat
                : DataFormat.Default;
            
            members.Add(
                new ProtoMember
                {
                    Name = property.Name,
                    Type = property.Type,
                    Tag = tag,
                    Compilation = compilation,
                    IsRequired = property.IsRequired,
                    IsInitOnly = property.SetMethod?.IsInitOnly == true,
                    AttributeData = property.GetAttributes(),
                    DataFormat = dataFormat,
                    MapFormat = (keyFormat,valueFormat),
                    ProtoReaderType = ReaderType,
                    ProtoWriterType = WriterType,
                }
            );
        }

        return members.OrderBy(m => m.Tag).ToList();
    }

    private class ProtoMember
    {
        public enum PbWireType
        {
            Varint = 0, // int32, int64, bool, enum ,uint32, uint64
            Fixed64 = 1, // double, fixed64, sfixed64
            LengthDelimited = 2, // string, bytes, message, repeated packed
            Fixed32 = 5, // float, fixed32, sfixed32
        }

        public Compilation Compilation { get; set; } = null!;

        public ITypeSymbol? ProtoReaderType { get; set; }
        public ITypeSymbol? ProtoWriterType { get; set; }
        public string Name { get; set; } = "";
        public ITypeSymbol Type { get; set; } = null!;
        public DataFormat DataFormat { get; set; }
        public (DataFormat keyFormat, DataFormat valueFormat) MapFormat { get; set; }
        public uint Tag { get; set; }
        public bool IsRequired { get; set; }
        public bool IsInitOnly { get; set; }

        public ImmutableArray<AttributeData> AttributeData { get; set; } =
            ImmutableArray<AttributeData>.Empty;

        public PbWireType WireType => GetPbWireType(Compilation, Type, DataFormat);

        public static PbWireType GetPbWireType(
            Compilation compilation,
            ITypeSymbol Type,
            DataFormat DataFormat
        )
        {
            // Handle nullable value types by getting the underlying type
            if (
                Type is INamedTypeSymbol namedType
                && namedType.OriginalDefinition?.SpecialType == SpecialType.System_Nullable_T
            )
            {
                return GetPbWireType(compilation, namedType.TypeArguments[0], DataFormat);
            }

            // Handle arrays, lists and sets
            if (IsCollectionType(compilation, Type))
            {
                return PbWireType.LengthDelimited;
            }

            // Handle dictionaries
            if (IsDictionaryType(compilation, Type))
            {
                return PbWireType.LengthDelimited;
            }

            if (Type.TypeKind == TypeKind.Enum)
            {
                return PbWireType.Varint;
            }

            switch (Type.SpecialType)
            {
                case SpecialType.System_Boolean:
                case SpecialType.System_Int32:
                {
                    return DataFormat == DataFormat.FixedSize
                        ? PbWireType.Fixed32
                        : PbWireType.Varint;
                }
                case SpecialType.System_UInt32:
                {
                    return DataFormat == DataFormat.FixedSize
                        ? PbWireType.Fixed32
                        : PbWireType.Varint;
                }
                case SpecialType.System_DateTime:
                case SpecialType.System_Int64:
                {
                    return DataFormat == DataFormat.FixedSize
                        ? PbWireType.Fixed64
                        : PbWireType.Varint;
                }
                case SpecialType.System_UInt64:
                {
                    return DataFormat == DataFormat.FixedSize
                        ? PbWireType.Fixed64
                        : PbWireType.Varint;
                }
                case SpecialType.System_Enum:
                    return PbWireType.Varint;
                case SpecialType.System_Single:
                    return PbWireType.Fixed32;
                case SpecialType.System_Double:
                    return PbWireType.Fixed64;
                case SpecialType.System_String:
                case SpecialType.None when Type.ToDisplayString() == "Google.Protobuf.ByteString":
                case SpecialType.None when IsGuidType(Type):
                case SpecialType.None when IsTimeSpanType(Type):
                case SpecialType.None when IsDateOnlyType(Type):
                case SpecialType.None when IsTimeOnlyType(Type):
                case SpecialType.None when IsStringBuilderType(Type):
                case SpecialType.None
                    when Type.TypeKind == TypeKind.Class
                        || Type.TypeKind == TypeKind.Interface
                        || Type.TypeKind == TypeKind.Array:
                    return PbWireType.LengthDelimited;
                default:
                    if (
                        Type.ToDisplayString()
                            .StartsWith("Google.Protobuf.Collections.RepeatedField")
                    )
                    {
                        // For simplicity, assume packed repeated fields use LengthDelimited
                        return PbWireType.LengthDelimited;
                    }

                    // Default to LengthDelimited for other complex types
                    return PbWireType.LengthDelimited;
            }
        }

        public uint RawTag => GetRawTag(Tag, WireType);
        public byte[] RawTagBytes => GetRawBytes(Tag, WireType);

        public static uint GetRawTag(uint Tag, PbWireType WireType)
        {
            return (Tag << 3) | (uint)WireType;
        }

        public static byte[] GetRawBytes(uint fieldNumber, PbWireType wireType)
        {
            uint tag = (fieldNumber << 3) | (uint)wireType;
            return EncodeVarint(tag);
        }

        private static byte[] EncodeVarint(uint value)
        {
            var bytes = new List<byte>();
            while (value > 127)
            {
                bytes.Add((byte)((value & 0x7F) | 0x80)); // 低7位 + 最高位1，表示后面还有字节
                value >>= 7;
            }

            bytes.Add((byte)value); // 最后一个字节
            return bytes.ToArray();
        }
    }
}
