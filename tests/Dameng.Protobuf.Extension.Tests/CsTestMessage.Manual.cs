// <auto-generated>
//     This file was generated by a tool.
//     Generated from: CsTestMessage
// </auto-generated>

using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Linq;
using Google.Protobuf;
using Google.Protobuf.Collections;
using Google.Protobuf.Reflection;
using Google.Protobuf.WellKnownTypes;
using Dameng.Protobuf.Extension;

namespace Dameng.Protobuf.Extension.Tests
{
    // Manual implementation to understand what we need to generate
    partial class CsTestMessage : IMessage<CsTestMessage>, IPbMessageParser<CsTestMessage>
    {
        private static readonly MessageParser<CsTestMessage> _parser = new MessageParser<CsTestMessage>(() => new CsTestMessage());
        public static MessageParser<CsTestMessage> Parser { get { return _parser; } }
        
        private static MessageDescriptor _descriptor = new MessageDescriptor(
            "CsTestMessage", 
            typeof(CsTestMessage),
            null, null, null, null, null);
        
        public static MessageDescriptor Descriptor => _descriptor;
        MessageDescriptor IMessage.Descriptor => Descriptor;
        
        private UnknownFieldSet _unknownFields;
        
        // Default constructor
        public CsTestMessage() { }
        
        // Copy constructor
        public CsTestMessage(CsTestMessage other) : this()
        {
            if (other == null) return;
            
            StringField = other.StringField;
            Int32Field = other.Int32Field;
            Int32ArrayField = new List<int>(other.Int32ArrayField);
            StringArrayField = new List<string>(other.StringArrayField);
            BytesField = other.BytesField;
            BoolField = other.BoolField;
            DoubleField = other.DoubleField;
            FloatField = other.FloatField;
            Int64Field = other.Int64Field;
            UInt32Field = other.UInt32Field;
            UInt64Field = other.UInt64Field;
            SInt32Field = other.SInt32Field;
            SInt64Field = other.SInt64Field;
            Fixed32Field = other.Fixed32Field;
            Fixed64Field = other.Fixed64Field;
            SFixed32Field = other.SFixed32Field;
            SFixed64Field = other.SFixed64Field;
            MapField = new Dictionary<string, string>(other.MapField);
            EnumField = other.EnumField;
            EnumArrayField = new List<CsTestEnum>(other.EnumArrayField);
            NestedMessageField = other.NestedMessageField?.Clone();
            NestedMessageArrayField = other.NestedMessageArrayField != null ? new List<CsTestMessage>(other.NestedMessageArrayField.Select(m => m?.Clone()).Where(m => m != null)) : new List<CsTestMessage>();
            OneofStringField = other.OneofStringField;
            OneofInt32Field = other.OneofInt32Field;
            OneofNestedMessage1 = other.OneofNestedMessage1?.Clone();
            OneofNestedMessage2 = other.OneofNestedMessage2?.Clone();
            TimestampField = other.TimestampField;
            DurationField = other.DurationField;
            MapField2 = new Dictionary<string, string>(other.MapField2);
            MapField3 = new ConcurrentDictionary<string, string>(other.MapField3);
            
            _unknownFields = UnknownFieldSet.Clone(other._unknownFields);
        }
        
        public CsTestMessage Clone()
        {
            return new CsTestMessage(this);
        }
        
        public override bool Equals(object other)
        {
            return Equals(other as CsTestMessage);
        }
        
        public bool Equals(CsTestMessage other)
        {
            if (ReferenceEquals(other, null)) return false;
            if (ReferenceEquals(other, this)) return true;
            
            return StringField == other.StringField &&
                   Int32Field == other.Int32Field &&
                   ListsEqual(Int32ArrayField, other.Int32ArrayField) &&
                   ListsEqual(StringArrayField, other.StringArrayField) &&
                   BytesFieldsEqual(BytesField, other.BytesField) &&
                   BoolField == other.BoolField &&
                   DoubleField == other.DoubleField &&
                   FloatField == other.FloatField &&
                   Int64Field == other.Int64Field &&
                   UInt32Field == other.UInt32Field &&
                   UInt64Field == other.UInt64Field &&
                   SInt32Field == other.SInt32Field &&
                   SInt64Field == other.SInt64Field &&
                   Fixed32Field == other.Fixed32Field &&
                   Fixed64Field == other.Fixed64Field &&
                   SFixed32Field == other.SFixed32Field &&
                   SFixed64Field == other.SFixed64Field &&
                   DictionariesEqual(MapField, other.MapField) &&
                   EnumField == other.EnumField &&
                   ListsEqual(EnumArrayField, other.EnumArrayField) &&
                   Equals(NestedMessageField, other.NestedMessageField) &&
                   ListsEqual(NestedMessageArrayField, other.NestedMessageArrayField) &&
                   OneofStringField == other.OneofStringField &&
                   OneofInt32Field == other.OneofInt32Field &&
                   Equals(OneofNestedMessage1, other.OneofNestedMessage1) &&
                   Equals(OneofNestedMessage2, other.OneofNestedMessage2) &&
                   TimestampField == other.TimestampField &&
                   DurationField == other.DurationField &&
                   DictionariesEqual(MapField2, other.MapField2) &&
                   DictionariesEqual(MapField3.ToDictionary(kv => kv.Key, kv => kv.Value), other.MapField3.ToDictionary(kv => kv.Key, kv => kv.Value)) &&
                   Equals(_unknownFields, other._unknownFields);
        }
        
        private static bool ListsEqual<T>(IList<T> a, IList<T> b)
        {
            if (a == null && b == null) return true;
            if (a == null || b == null) return false;
            if (a.Count != b.Count) return false;
            for (int i = 0; i < a.Count; i++)
            {
                if (!object.Equals(a[i], b[i])) return false;
            }
            return true;
        }
        
        private static bool DictionariesEqual<K, V>(IDictionary<K, V> a, IDictionary<K, V> b)
        {
            if (a == null && b == null) return true;
            if (a == null || b == null) return false;
            if (a.Count != b.Count) return false;
            foreach (var kv in a)
            {
                if (!b.TryGetValue(kv.Key, out var value) || !object.Equals(kv.Value, value))
                    return false;
            }
            return true;
        }
        
        private static bool BytesFieldsEqual(byte[] a, byte[] b)
        {
            if (a == null && b == null) return true;
            if (a == null || b == null) return false;
            if (a.Length != b.Length) return false;
            for (int i = 0; i < a.Length; i++)
            {
                if (a[i] != b[i]) return false;
            }
            return true;
        }
        
        public override int GetHashCode()
        {
            int hash = 1;
            if (StringField != null) hash ^= StringField.GetHashCode();
            hash ^= Int32Field.GetHashCode();
            if (Int32ArrayField != null)
                foreach (var item in Int32ArrayField) hash ^= item.GetHashCode();
            if (StringArrayField != null)
                foreach (var item in StringArrayField) hash ^= (item?.GetHashCode() ?? 0);
            if (BytesField != null) hash ^= BytesField.GetHashCode();
            hash ^= BoolField.GetHashCode();
            hash ^= DoubleField.GetHashCode();
            hash ^= FloatField.GetHashCode();
            hash ^= Int64Field.GetHashCode();
            hash ^= UInt32Field.GetHashCode();
            hash ^= UInt64Field.GetHashCode();
            hash ^= SInt32Field.GetHashCode();
            hash ^= SInt64Field.GetHashCode();
            hash ^= Fixed32Field.GetHashCode();
            hash ^= Fixed64Field.GetHashCode();
            hash ^= SFixed32Field.GetHashCode();
            hash ^= SFixed64Field.GetHashCode();
            if (MapField != null) hash ^= MapField.GetHashCode();
            hash ^= EnumField.GetHashCode();
            if (EnumArrayField != null)
                foreach (var item in EnumArrayField) hash ^= item.GetHashCode();
            if (NestedMessageField != null) hash ^= NestedMessageField.GetHashCode();
            if (NestedMessageArrayField != null)
                foreach (var item in NestedMessageArrayField) hash ^= (item?.GetHashCode() ?? 0);
            if (OneofStringField != null) hash ^= OneofStringField.GetHashCode();
            if (OneofInt32Field != null) hash ^= OneofInt32Field.GetHashCode();
            if (OneofNestedMessage1 != null) hash ^= OneofNestedMessage1.GetHashCode();
            if (OneofNestedMessage2 != null) hash ^= OneofNestedMessage2.GetHashCode();
            hash ^= TimestampField.GetHashCode();
            hash ^= DurationField.GetHashCode();
            if (MapField2 != null) hash ^= MapField2.GetHashCode();
            if (MapField3 != null) hash ^= MapField3.GetHashCode();
            if (_unknownFields != null) hash ^= _unknownFields.GetHashCode();
            return hash;
        }
        
        public override string ToString()
        {
            return JsonFormatter.ToDiagnosticString(this);
        }
        
        // Basic serialization - for now, delegate to a simple conversion
        public void WriteTo(CodedOutputStream output)
        {
            // This is a simplified implementation
            // In reality, we'd need to properly encode each field according to protobuf wire format
            if (_unknownFields != null)
                _unknownFields.WriteTo(output);
        }
        
        public int CalculateSize()
        {
            int size = 0;
            // Calculate size of all fields - simplified for now
            if (_unknownFields != null)
                size += _unknownFields.CalculateSize();
            return size;
        }
        
        public void MergeFrom(CsTestMessage other)
        {
            if (other == null) return;
            // Merge logic - simplified for now
            _unknownFields = UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }
        
        public void MergeFrom(CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                // Parse fields from input - simplified for now
                _unknownFields = UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
        }
    }
}